created at : 2024-07-24 09:43

#### tags

#

--- 

- Part 2: 객체지향 프로그래밍 패러다임
	- 객제지향 : 코드를 구성하는 기본 단위를 객체로 정하고 코드 설계의 초석을 캡슐화, 추상화, 상속, 다형성을 사용한다.
		- 캡슐화
			- 클래스가 가진 데이터를 외부에 제한적으로 공개한다.
			- 데이터와 로직이 해당 클래스 내부에 모여 있기 때문에 유지보수가 용이하다.
		- 추상화
			- 클래스끼리 공통된 로직을 추상화한다.
			- 구현의 세부사항을 알 필요없이 기능을 사용할 수 있다.
		- 상속
			- 클래스끼리 is-a 관계를 나타낼 수 있다.
			- 상위 클래스의 기능을 하위 클래스가 재사용하거나 재정의할 수 있다.
		- 다형성
			- 코드를 실행할 때 하위 클래스 타입 대신 상위 클래스 타입으로 사용할 수 있다.
	- 객체지향 분석, 설계, 프로그래밍을 수행하는 방법
		- 요구사항 분석은 어떻게?
			- 지속적인 반복 최적화 프로세스
			- 문제를 먼저 파악한 후, 그 문제를 해결하는 방법 - 좋은 반복 최적화 방법.
			- 대략적으로 큰 틀을 잡고 하나씩 지적하면서 해결책을 찾는다.
		- 책임 분담은 어떻게? 어떤 클래스를 정의해야?
			- 일단 요구사항에 나온 명사를 가능한 후보 클래스로 나열.
			- 이후 필터링
			- 추천 방법
				- 요구사항 명세에 따라 관련된 기능들을 하나씩 나열한 후, 어떤 기능들이 유사한 책임을 지고 동일한 속성을 사용하는지 확인.
				- 기능들을 '단일 책임'으로 분해
				- 하나의 단위(클래스)로 묶을 수 있는 기능끼리 모아서 이름을 정한다.
		- 각 클래스에는 어떤 속성과 메서드가 있어야?
			- 위에서 파악한 클래스와 기능에서 동사, 명사를 추출해서 메서드와 속성을 정의한다.
			- 이렇게 정의하다보면 요구사항에는 없지만 설계를 위해서 따로 클래스를 더 만들 수가 있다.
				- 이 클래스가 가져야 할 책임인가?
				- 단일 책임을 지키고 있는가?
			- 몇몇 기능은 세부사항을 알 필요가 없다. -> 추상화한다.
		- 각각의 클래스는 어떻게 상호작용해야?
			- 사용하는 용어
				- 일반화 : extends
				- 실체화 : implements
				- 집합(aggregation) : 클래스 A는 클래스 B가 속성으로 포함된다. (A가 초기화할 때 B는 주입받음. 생명주기가 종속되지 않을 수도 있다)
				- 합성(composition) : 클래스 A는 클래스 B의 인스턴스를 속성으로 포함하면서, 생명주기도 함께한다. (A가 초기화할 때 B도 같이 초기화 됨)
				- 연관(association) : aggregation + composition 둘 다 가지는 관계
				- 의존(dependancy) : 연관보다 더 약한 관계. 속성 + 메서드파라미터 + 반환 값 + 지역 변수 등 아무튼 클래스끼리 어떠한 관계가 있는 경우
		- 클래스를 실행 가능한 프로그램으로 조합하는 방법은?
			- main 함수일 수도 있고 특정 클래스일 수도 있다.
	- 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍
		1. getter, setter 메서드 남용
		2. static 변수, 메서드 남용
			- 상수 클래스에 종속된 클래스가 많을 수록 불필요한 컴파일 시간이 늘어남.
			- 이건 단위테스트 시간에도 영향을 미친다.
			- 굳이 따로 static 변수로 만들지 말고 클래스가 가져야할 상수라면 해당 클래스 내부에 넣기
			- Utils 클래스는 다른 클래스 내부에도 정의할 수 없는 클래스라면 과감하게 정의하자.
				- 너무 객체지향만 신경써서 개발하면 효율이 안 나옴
		3. 데이터와 메서드 분리로 클래스 정의
			- 데이터는 데이터 클래스로 정의하고 그 데이터를 사용하는 메서드는 다른 클래스에 정의되는 형태
			- VO, Entity, BO를 따로 정의하고 해당 로직을 다루는 메서드는 Service에 정의하는 MVC패턴
			- 필요에 따라서는 절차적 프로그래밍을 사용할 수도 있음
	- 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?
		- 빈약한 도메인 모델 == 트랜잭션 스크립트 패턴
		- 풍부한 도메인 모델을 기반한 DDD 개발 방식
			- 사실상 애자일 개발, SOA, Pass 등과 유사
			- 비지니스 로직이 Domain 클래스에 있다.
		- 두 가지 개발 방식 비교
			- service 클래스가 가벼워짐.
				- service의 책임은?
					- repository 계층과 통신
					- 여러 도메인 모델의 비지니스 로직을 결합하기. (도메인 모델이 여러개 사용될 경우 초기화 등)
					- 기능과 무관한 상호작용들 (트랜잭션, 이메일 발송, 로깅, 메시지 보내기, 다른 시스템과 통신 등)
			- controller와 repository도 빈약하게 되었다.
				- 상관없음.
			- 비지니스 로직이 단순하면 빈약한 도메인도 상관이 없다.
			- 대부분 작업은 SQL기반 CRUD 작업이다. 과연 풍부한 도메인이 필요한가?
			- 풍부한 도메인은 설계가 까다롭다.
			- 단순히 service에 있는 로직을 도메인 클래스에 넣는 것이 풍부한 도메인 개발이 아니다.
	- 추상클래스와 인터페이스
		- 추상 클래스
			- 단일 상속만 가능
			- 초기화 불가능
			- 속성과 메서드를 포함할 수 있음
			- 추상 메서드를 통해서 하위 클래스가 구현하도록 할 수 있음
		- 인터페이스
			- 다중 상속 가능
			- 추상 메서드만 선언 가능
			- 속성 포함 불가
			- java 8 이후
				- 속성, default method, private 메서드 구현 가능
				- 추상 클래스의 기능 대부분을 포함할 수 있다.
		- 명확하게 is-a 관계를 나타내고 싶다면 추상, has-a 관계는 인터페이스
		- 인터페이스는 단순히 추상화가 아닌 일종의 '기능 목록'이다.
			- 외부에서 상호작용을 하고자 할 때, 어떤 것이 제공되는지 알려주는 것.
			- 추상 클래스도 이렇게 사용할 수 있다.
		- 인터페이스 남용
			- 구현방법이 1개 뿐이고 대체할 필요가 없다면 그냥 구체 클래스
			- 여러 방법으로 구현될 경우 인터페이스 사용
	- 상속보단 합성
		- 상속보단 합성이 확장에도 유리하고 코드를 이해하기 쉽다(상대적)
		- 상속 레벨이 낮고(2단계 이하) 관계가 단순하다면 상속도 나쁘지 않다

- Part 3: 설계원칙
	- SOLID
		- single responsibility principle
			- 클래스와 모듈 두 가지 종류가 있다.
			- 클래스가 단일 책임인걸 어떻게 아는가?
				- 요구사항에 따라 현재 클래스가 단일 책임일 수도 아닐 수도 있다.
				1. 코드, 메서드, 속성이 너무 많아서 가독성과 유지보수가 어렵다 -> 단일 책임 아닐 수도
				2. private 메서드가 너무 많은 경우 -> 단일 책임 아닐 수도
				3. 클래스가 너무 과하게 다른 클래스에 의존할 경우 (응집도가 낮고 결합도가 높은 경우) -> 단일 책임 아닐 수도
				4. 클래스의 이름을 명확하게 정의하기 어렵거나 Manager, Context 등 일반적인 단어가 아니라면 클래스 이름을 정의할 수 없는 경우 -> 단일 책임 아닐 수도
				5. 여러 속성 중 메서드가 일부 속성만 사용할 경우 -> 단일 책임 아닐 수도
			- 결국 최종 목표는 가독성, 확장성, 재사용성, 유지보수성임. 설계원칙은 수단일 뿐. 
		- open closed principle
			- 클래스, 모듈, 함수와 같은 소프트웨어 단위들은 확장에 열려 있고 수정에는 닫혀 있다.
			- 예) 알람 기능에 옵저버 패턴, 데코레이터 패턴 등 적용
			- 간단한 가이드 라인
				- 기존 코드에 확장할 때는 개방, 수정할 때는 폐쇄일 경우 잘 지킨 것임
				- 확장 가능한 코드는 확장, 추상화, 캡슐화에 대해 인식하고 있는 것이 중요
				- 현재 코드가 앞으로 확장될 가능성이 있는지 알 필요가 있다.
				- 변경 가능한 부분과 변경할 수 없는 부분을 잘 식별할 것. 변경되는 사항은 캡슐화하여 분리하고 변경이 안 될 부분은 추상화를 해라. (상위 시스템에서 사용할 경우)
			- 유연하게 적용하기
				- 미리 적용하면 유용하지만 굳이 구현 비용이 적은 부분까지 미리할 필요가 없다.
		- liskov subsitution principle
			- 하위 타입은 상위 타입으로 대체가 가능하며, 논리를 변경하지 않아도 동작한다.
			- 리스코프 치환과 다형성의 차이
				- 사실 같은 의미 아님?
					- 다르다.
					- 만약 하위 클래스에서 특정 조건을 만족하지 않을 때 예외를 던진다고 가정.
					- 그렇다면 상위 클래스를 사용하는 입장에서도 예외를 잡아야 할 수 있다.
					- 이러면 원칙을 위배
					- 하지만 다형성을 통해 구현한 방법임.
					- 즉, 다형성을 통해서 상위 클래스를 통해 사용해도 '수정없이 논리적으로 잘 동작해야 한다.'
			- LSP == design by contract (계약에 따른 설계)
		- interface segregation principle
			- 클라이언트는 필요하지 않은 인터페이스를 사용하도록 강요되어서는 안 된다.
			- 단일 책임과 유사;
			- 내가 굳이 필요하지 않는 기능을 상속해서 구현할 필요가 있는가?
		- dependency inversion principle
			1. 의존 역전이 뜻하는 것은 어떤 대상 사이의 역전? 그리고 어떤 의존이 역전되는 것? 역전이란 무엇?
				 - 제어는 프로그램의 실행 흐름을 제어
				 - 역전은 프레임워크를 사용하기 전에 직접 작성했던 코드들의 실행 흐름
			2. IoC, DI와 무슨 차이?
				- IoC
					- 즉, 프레임워크에 의해 프로그램의 실행 흐름이 제어되고 프로그래머에서 프레임워크로 역전이 되는 것
				- DI
					- 클래스 내부에 종속된 클래스를 초기화할 때 new 대신 외부에서 생성된 객체를 생성자, 메서드의 파라미터 등을 통해 주입하는 것.
			3. 실제로 적용된 Spring에서 IoC는 어떤 관련이 있는가?
				- DI 프레임워크
					- 결국 의존성 주입은 어디선가 누가 해주는 것.
					- 프로그래머가 코드로 작성하는 대신에 프레임워크가 알아서 해준다. DI 프레임워크의 역할
			- 의존성 역전 원칙은?
				- 상위 모듈은 하위 모듈에 의존하지 않아야 하며, 추상화에만 의존한다.
	- KISS 원칙, YAGNI 원칙
		- KISS - Keep It Simple and Stupid, simple, short blabla
			- 코드의 품질은 유지보성과 가독성이 매우 중요하다.
			- 코드를 단순하게 유지하라.
				- 단순?
					- 짧거나 직접 구현했다고 단순하지 않는다.
					- 복잡하게 보인다고 해서 KISS를 어긴 것은 아니다. (검증된 알고리즘 사용 등)
			- 과하게 최적화하지 않고 복잡한 기술을 사용하지 않으며너 기존 라이브러리를 사용했다면 지켰다고 할 수도 있다.
		- YAGNI - You ain't gonna need it
			- 현재 필요하지 않으면 미리하지 말라
	- DRY 원칙
		- DRY - Don't repeat yourself
			- 코드가 중복되었다고 반드시 DRY가 위배되는 것은 아님
			- 그럼 무엇이 위반?
				- 로직 중복
				- 의미론적 중복
				- 코드 실행 중복
	- LoD
		- Law of Demeter
			- 최소 지식의 원칙이라고도 함.
			- 자신과 매우 밀접하게 관련된 유닛에 대해서 제한적인 지식만 알아야 한다.
			- 결국 높은 응집도, 낮은 결합도
			- 굳이 필요없는 의존성을 만들지 말라
		- 그렇다면 DTO처럼 데이터 클래스를 사용할 경우?
			- 예제에 나오는 NetworkTransporter가 HtmlRequest를 알 필요가 있는가?
			- 이 때는 오히려 String, Byte[] 타입으러 파라미터를 정의하는 것이 좋다.
			- 굳이 Html인지 알 필요가 없다. 통신을 위해서 주소와 컨텐츠만 있으면 된다.
		- Serialization에서 serialize, deserialize를 둘 다 제공할 경우
			- 보기에는 문제가 없어 보이나, 해당 클래스를 사용하는 쪽에서는 1가지 목적만으로 사용할 수 있다.
			- 둘로 나눠서 다른 클래스로 만든다.
				- 이것이 과연 응집도가 높은가?
				- serialize에서 json, xml, etc ...가 추가된다면 deserialize도 같이 추가가 되어야 한다.
				- 즉, 수정 범위가 넓어진다.
				- 하지만 하나로 사용할 경우 LoD를 위반하게 됨.
			- Serializable, Deserializable 인터페이스 둘로 나눠서 Serialization 클래스가 원하는 기능만 상속해서 구현하도록 한다.
				- 상위 타입이 Serializable일 경우 Serialization 클래스는 serialize만 사용가능, 반대도 마찬가지
				- 둘 다 쓰고 싶다면 구체 타입을 정의한다.
				- Spring에서 상위타입을 지정해서 원하는 기능만 사용할 수 있던게 이런 이유인듯.
				- 새로운 지식을 알게 됨.

- Part 4: 코딩 규칙

- Part 5: 리팩터링 기법
	- 리팩터링의 4가지 요소
		- 목적
			- 코드에 대한 이해를 쉽게하기 위해 소프트웨어 내부 구조를 개선한다. 외부 동작은 변경하지 않고 수정 비용을 줄인다.
			- 프로그램이 커지다보면 코드 품질이 점점 나빠진다. (신경써서 개발할지라도!)
			- 미리미리 리팩터링을 해서 코드 품질 저하로 인한 여러 피해를 막을 수 있다.
		- 대상
			- 대규모일 경우, 시스템, 모듈, 코드 구조, 클래스 간 관계 등을 포함한다.
			- 소규묘일 경우, 표준 명명, 표준 주석, 갓 클래스 제거, 함수 제거, 중복 코드 추출 등
		- 시기
			- 정해진 시기는 없다.
			- 지속적인 관심이 필요. (단위 테스트, 코드 리뷰 등)
		- 방법
			- 규모마다 다르게 다루어야 한다.
			- 수석 엔지니어의 생각과 경험이 많이 반영되는 듯?
	- 단위 테스트
		- 코드의 정확성을 위한 테스트. 통합 테스트보다 작다. 코드 수준의 테스트.
		- 장점
			- 버그를 찾는데 도움을 준다.
			- 설계의 문제를 찾는데 도움을 준다.
				- 단위 테스트를 작성하는데 어렵거나 단위 테스트 프레임워크의 고급 기능에 의존해야 할 경우 설계가 잘못되었다는 신호이다.
			- 통합 테스트를 보완하는 테스트이다.
			- 단위 테스트를 작성하면서 지속적인 리팩토링이 가능하다.
			- 프로그래머가 코드에 빠르게 익숙해진다.
		- 설계 방법
			1. 다양한 입력, 예외, 경계 조건을 다루는 테스트 케이스 설계
			2. 프레임 워크 활용
		- 단위 테스트 커버리지는 반드시 100%일 필요는 없으나 케이스 여부를 잘 파악해서 작성하는 것이 중요하다
		- 단위 테스트를 작성하기 어려운 이유
			1. 테스트 작성에 노력이 필요하니 그만큼 시간이 더 소모된다.
			2. 단위테스트도 리팩토링이 필요하다.
	- 코드 테스트 용이성
		- 그렇다면 '테스트하기 좋은 코드'란?
			- 코드에서 외부에 의존하는 것을 최대한 제거한다.
				- 필요하다면 의존성 주입이 가능한 형태로 만들기
			- 클래스가 높은 응집도와 낮은 결합도가 만족할 경우
		- 테스트가 불가능한 코드
			- 보류 중인 동작
				- 무작위, 시간, 난수 등
			- 전역 변수
			- 정적 메서드
			- 복잡한 상속 관계
	- 디커플링
		1. 코드를 디커플링해야 하는지 판단하기
			- 일부를 수정하는데 전체를 건드려야 하는 상황이 발생
			- 모듈과 클래스 간의 의존성 그래프가 너무 복잡한 경우 (분석 도구 그래프를 그려보기, 직관적)
		2. 코드 디커플링 방법
			1. 캡슐화와 추상화로 디커플링
			2. 중간 계층으로 디커플링하기
				- Repository 패턴이 대표적
			3. 모듈화와 계층화로 디커플링
				- 아예 모듈로 나눠버린다.
				- mvc 패턴
			4. 고전적인 코드 설계 원칙과 사상을 사용한 디커플링
				- SOLID, 상속보단 조합, LoD, DI, DRY, YAGNI 등
	- 코드 품질 문제 찾기
		1. 모듈의 구분이 명확하고 코드 구조가 높은 응집도, 낮은 결합도를 충족하는가?
		2. 코드가 고전적인 설계 원칙을 따르고 있는가?
		3. 디자인 패턴이 제대로 적용되었고, 과도하게 설계되지 않았는가?
		4. 코드는 확장하기 쉬운가?
		5. 코드를 재사용할 수 있는가? 다른 도구에서 미리 구현한 것이 있는가?
		6. 코드는 테스트하기 쉬우며, 단위 테스트가 정상, 비정상을 포괄적으로 다루고 있는가?
		7. 코드가 적절한 명명, 주석, 균일한 코드 스타일, 코딩 규칙을 준수하였는가?
	- 코드 품질 외에도 비지니스 고유 기능과 요구사항을 충족하는지 검토하기
		1. 의도했던 비지니스 요구 사항을 모두 구현했는가?
		2. 코드의 논리가 올바르고 발생할 가능성이 있는 다양한 예외를 처리했는가?
		3. 스레드 안전성은?
		4. 최적화할 여지가 있는지?
		5. 코드에 허점이 존재하는지?
	- 단계적 리팩토링
		1. 코드 가독성을 높인다.
		2. 코드의 테스트 용이성을 높인다.
		3. 단위 테스트 코드를 작성한다.
		4. 예외 처리 로직을 개선한다.

- Part 6: 생성 디자인 패턴
	1. 싱글턴 패턴
		- 인스턴스를 단 1개만 생성
		- 단점
			- 클래스 간 의존성을 감춘다. (명시적으로 생성하지 않기 때문에)
			- 확장성에 영향을 미친다. (확장, 추가 인스턴스, 전역 클래스가 가진 문제)
			- 테스트 코드 용이성에 영향을 미친다.
		- 싱글턴 대안
			- DI 컨테이너
			- 전역적인 유일성을 보장하면서 확장 가능하고 테스트가 용이하게
		- 스레드 전용 싱글턴 패턴
			- 기존 싱글턴 패턴은 프로세스 내부에서 유일성을 보장
			- 스레드 전용 싱글턴은 싱글턴이 스레드 내부에서만 보장됨.
		- 클러스터 환경에서의 싱글턴 패턴
			- 여러 프로세스 사이에서 유일성을 보장
			- 직렬화, 역직렬화, 다른 프로세스가 작업 중일 때 접근 제어 락 등이 필요
		- 다중 인스턴스 패턴
			- 싱글턴과 달리 여러개를 생성할 수는 있지만 개수가 제한됨.
	2. 팩토리 패턴
		- 단순 팩토리 패턴
			- 특정 조건에 따라 객체를 만들어주는 패턴
			- 설계가 단순하다면 if 분기가 있어도 상관은 없다.
		- 팩토리 메서드 패턴
			- 기존 단순 팩토리 패턴에서 if 분기를 제거하기 위해서 다형성 사용
			- 기존 팩터리에서 if 분기가 없어지긴 했느데 오히려 client 단에서 if 분기가 생김.
			- 팩터리의 팩터리를 만들기 (map으로 전달)
				- 클라이언트 단에서 if 분기 삭제 가능
		- 추상 팩토리 패턴
			- 만약 새로운 객체를 계속해서 추가해야 한다면?
			- 인터페이스에 새로운 팩터리용 메서드를 추가한다.
				- 이렇게하면 기존 코드에 추가할 생성 로직이 각 팩터리 구체 클래스로 분산이 된다.
		- 팩토리 패턴이 사용될 때
			- if 분기 판단이 있고 유형에 따라 객체를 동적으로 생성하는 경우. 이걸 추출해서 따로 팩토리 클래스로 만들어 사용할 수 있다.
			- 단일 객체 자체의 생성 프로세스가 비교적 복잡한 경우. 굳이 if로 분기가 없어도 복잡한 로직이라면 따로 클래스에 담아두는 것도 좋다. (캡슐화)
		- DI 컨테이너와 팩터리 패턴의 차이
			- DI 컨테이너
				- 일종의 큰 팩토리 클래스
				- 클래스에 따라 각각의 객체가 생성될 수 있도록 판단하여 미리 객체를 생성하는 역할
				- 설정 분석, 객체 생성, 객체 생명 주기 관리가 핵심 3가지
					- 생명 주기 관리
						- 미리 생성해둔 것이 있다면 그걸 반환한다.
						- 지연적재 - 호출되는 시점에 객체를 생성한다.
	3. 빌더 패턴
		- 생성자를 사용하는 방법은 오류를 범할 수 있고 가독성이 나빠진다.
		- 빌더 패턴과 팩토리 패턴의 차이
			- 객체를 생성할 때 사용하는 디자인 패턴인 것은 동일
			- 팩토리 패턴은 동일한 상위 클래스 or 인터페이스를 상속하는 하위 클래스에 대한 것.
			- 동일한 유형의 객체를 매개변수를 통해 설정하여 생성하는 방법
	4. 프로토타입 패턴
		- 객체 생성을 할 때 복잡한 정렬, hash 값 계산, RPC, 네트워크, 데이터베이스, 파일 시스템 접근 등과 같이 시간이 오래 걸리는 경우 프로토타입 패턴을 사용해서 기존 객체를 직접 복사하여 생성할 수 있다.
		- 새 객체가 생성될 때 위와 같은 소모적인 작업을 줄일 수 있다.
		- java에서는 clone() 메서드가 객체 메모리 주소만 복사한다. (얕은 복사임)
		- 깊은 복사 방법
			1. 재귀적으로 복사하는 방법
			2. 직렬화한 다음 새 객체로 역직렬화 하는 방법
		- 재귀적 방법 최적화
			- 일단 얕은 복사를 진행해서 필요한 부분만 깊은 복사를 진행
			- 복사를 하는 이유가 업데이트인 이유일 경우에만 유효할 듯

- Part 7: 구조 디자인 패턴
	- 특정 시나리오의 문제를 해결하는데 사용
	1. 프록시 패턴
		- 자주 사용되는 패턴
		- 인터페이스 기반의 프록시 패턴
		- 상속 기반의 프록시 패턴
			- 원본 클래스가 내가 수정할 수 없는 코드일 경우
			- 원본 클래스를 extends해서 상속으로 구현한다.
		- 리플렉션 기반의 동적 프록시
			- 위 방법들 모두 내가 직접 클래스를 생성한다.
			- 동적으로 생성하는 방법
		- 활용
			- 주요 비지니스 로직과 관련 없는 요구사항 개발에 사용
				- 모니터링, 인증, 통계, 트래픽 제한, 트랜잭션, 멱등성, 로깅 등
			- RPC 통신 등 네트워크 작업에 사용
			- 캐싱
				- 요청에 대한 응답을 해당 클래스를 호출하지 않고 캐싱된 데이터로 반환한다. 등
	2. 데코레이터 패턴
		- Java IO 클래스 라이브러리가 가지고 있는 기본 설계 사상
			- 바이트 스트림
				- InputStream
				- OutputStream
			- 문자열 스트림
				- Reader
				- Writer
			```
			InputStream in = new FileInputStream("text.txt");
			InputStream bin = new BufferedInputStream(in);
			```
			- 왜 이런 구조인가
				- 그냥 new BufferedInputStream("text.txt"); 이게 더 편하지 않는가?
				- 상속 기반 설계
					- 라이브러리를 상속으로 설계할 경우 IO 라이브러리가 너무 커질 수 있기 때문에 합성을 사용했다.
					- 실제 InputStream 아래에는 수 많은 하위 클래스가 존재한다.
			- 상속보단 합성은 상속 구조가 복잡해질 때 유용하다.
			- 데코레이터 패턴은 중첩이 가능하다.
				```
				InputStream in = new FileInputStream("text.txt");
				InputStream bin = new new BufferedInputStream(in);
				DataInputStream din = new DataInputStream(bin);
				```
			- 프록시와 데코레이터도 합성을 사용하는데 둘이 무슨 차이?
				- 프록시 - 원본 클래스와 관련 없는 기능을 추가한다.
				- 데코레이터 - 원본 클래스와 관련 깊은 기능을 추가한다.
	3. 어댑터 패턴
		- 호환되지 않는 인터페이스를 호환이 되도록 하는 방법
		- 상속기반 구현
			```
			interface Target { // target은 내가 원하는 인터페이스임.
				void a();
				void b();
				void c();
			}

			class Adaptee { // 기존 설계
				void fa() {}
				void fb() {}
				void fc() {}
			}

			class Adaptor extends Adaptee implements Target {
				void a() {
					super.fa();
				}
				
				//...
			}
			```
		- 합성 기반 구현
			```
			interface Target { // target은 내가 원하는 인터페이스임.
				void a();
				void b();
				void c();
			}

			class Adpatee { // 기존 설계
				void fa() {}
				void fb() {}
				void fc() {}
			}

			class Adaptor implements Target {
				Adaptee adaptee;

				Adaptor(Adaptee adaptee) {
					this.adaptee = adaptee;
				}

				void a() {
					adaptee.fa();
				}
			}
			```
		- 둘 중 어느것을 사용?
			- 굳이 복잡한 상속 구조를 사용할 필요가 있는가?
			- 그냥 합성이 좋을 듯
		- 응용
			- 일반적으로 기존 설계를 교정하는 패턴
			- 이걸 적용할 정도라면 이미 초기 설계가 문제가 있다는 뜻
			- 인터페이스의 비호한성에서 비롯한 문제
				1. 결함이 있는 인터페이스 설계가 캡슐화된 경우
				2. 여러 클래스의 인터페이스 설계를 통합할 경우
				3. 사용 중인 외부 시스템을 교체해야 할 경우
				4. 이전 버전 인터페이스와 호환성이 필요한 경우
				5. 다양한 형식의 데이터에 적용해야 할 경우
					- 배열로 전달된 데이터를 컬렉션으로 변환하는 경우
		- 자바 로깅과 어뎁터 패턴
			- Log4j, Logback, JUL, JCL 등 다양한 로깅 프레임 워크가 있다.
			- 이것들 모두 인터페이스가 다 다르다.
			- slf4j은 통합된 인터페이스 사양을 제공
		- 래퍼 패턴
			- 프록시, 데코레이터, 어댑터 모두 래퍼 패턴임
			```
			interface InterfaceClass { 
				void a();
				void b();
				void c();
			}

			class OriginalClass {
				void fa() {}
				void fb() {}
				void fc() {}
			}

			class WrapperClass implements InterfaceClass {
				OriginalClass original;

				Adaptor(OriginalClass original) {
					this.original = original;
				}

				void a() {
					// 부가 기능 추가
					original.fa();
				}

				void b() {
					original.fb();
				}
			}
			```
		- 이 구조를 대부분 따른다.
	4. 브릿지 패턴
		- 추상화와 구현은 디커플링해야만 두 가지가 서로 독립적으로 변환할 수 있다.
		- 위 패턴들과 무슨 차이점?
			- 그냥 상속대신 합성을 사용하라는 것과 다를 바가 없다.
			- 합성을 사용할 때 인터페이스를 사용하라. 이것만 차이있음.
	5. 퍼사드 패턴
		- 서브 시스템에 대한 통합 인터페이스 세트를 제공하고, 하위 시스템을 더 쉽게 만들기 위한 상우 ㅣ통합 인터페이스를 제공
		- 설계할 때 인터페이스를 너무 세분하게 나누면 해당 인터페이스를 호출하기 번거롭다. 너무 큰 단위로 인터페이스를 설계할 경우 단일 책임을 어기게 됨.
		- 퍼사드를 통해서 a,b,c,d... 인터페이스를 x로 제공할 수 있다.
			- a,b,c,d가 독립적인 시스템일 경우에도 퍼사드를 적용할 수 있음.
		- 인터페이스 버젼 캡슐화 아닌가?
	6. 복합체 패턴 (composite pattern)
		- 상속대신 합성(composite)과 관련이 없다.
		- 주로 tree 구조를 처리하는 데 사용이 된다.
	7. 플라이웨이트 패턴
		- 객체를 재사용하여 메모리를 절약하는 것.
		- 플라이웨이트 패턴과 싱글턴, 캐시, 오브젝트 풀의 차이는?
			- 플라이웨이트 vs 싱글턴
				- 싱글턴은 시스테멩서 하나의 객체만 허용
				- 플라이웨이트는 여러 객체 생성 가능. 단, 코드에서 사용되는 객체를 재사용(static으로 만들거나)
			- 플라이웨이트 vs 캐싱
				- 일반적인 캐싱은 접근 효율성을 위해서 사용하는 단어임.
				- 엄밀히 말하자면 캐싱과 객체의 재사용은 다르다.
			- 플라이웨이트 vs 오브젝트 풀
				- 오브젝트 풀 - 메모리 파편화를 막기 위해서 미리 연속적인 메모리 공간을 준비.
					- 이러한 객체 풀을 오브젝트 풀이라고 한다.
					- 객체가 생성될 때마다 객ㅊ를 꺼내서 사용, 사용후 다시 객체 풀에 반환
				- 플라이웨이트는 공동 사용이 목적. 오브젝트 풀은 반복 사용이 목적.

- Part 8: 행동 디자인 패턴
	1. 옵저버 패턴
		- 많은 객체들 사이에서 일대일 의존 관계가 정의되어 있을 때, 어느 한 객체의 상태가 변경되면 이 객체에 의존하고 있는 모든 객체는 자동으로 알림을 받는다.
		- 이메일 구독, rss 피드 등에 활용
		- 동기식 차단 옵저버 패턴
			- 옵저버 코드와 옵저버블 코드가 동일한 스레드에서 실행
			- 모든 '관찰'이 종료될 때까지 다른 작업은 블로킹됨.
				- sendMessage()를 호출했을 때 모든 옵저버블들이 반응할 때까지 블로킹
		- 비동기식 차단 옵저버 패턴
			- 옵저버 코드와 옵저버블 코드가 서로 다른 코드에서 실행이 된다.
				- sendMessage()를 호출해도 결과가 즉시 클라이언트에게 반환됨.
		- 교차 프로세스 옵저버 패턴
			- sendMessage()가 외부 네트워크로 통신될 때 사용.
		- 내부 프로세스 옵저버 패턴
			- 위처럼 프로세스 외부로 통신을 하지만, 같은 컴퓨터인 경우
		- async-non blocking 옵저버 패턴
			- sendMessage를 호출할 때 실제로 동작하는 로직이 다른 스레드에서 동작한다.
		- eventBus 프레임워크
			- 옵저버패턴을 구현한 backbone 코드를 제공
			- guava는 async non blocking, sync blocking도 둘 다 지원함 
	2. 템플릿 메서드 패턴
		- 하나의 메서드 안에 정의된 알고리즘 골격으로, 일부 작업 단계를 하위 클래스로 넘길 수 있어 하위 클래스가 알고리즘 전체 구조를 변경하지 않고도 알고리즘 일부를 변경할 수 있다.
		- 전체적인 흐름은 상위 클래스에서 추상화하고 세부적인 구현은 하위 클래스가 구현하도록 한다.
		- 예시
			- InputStream, AbstractList, Servlet, Junit의 TestCase
		- 콜백의 원리와 구현
			- 일반 메서드는 단방향 호출 관계.
			- 콜백은 양방향 호출 관계
				- class A가 f()를 콜백 함수로 등록한 뒤, A가 class B의 p()를 호출하면, B는 A가 등록해둔 f()를 차례대로 호출.
				- 어떻게 f()를 콜백으로 등록하는가
					- c에서는 포인터, java에서는 콜백함수를 감싸는 객체로 전달
				- 콜백 정의
					- 다른 함수에 인자로 전달되는 함수
					- 주어진 작업이 완료가 되면 전달된 콜백 함수가 호출된다.
			- 동기식 콜백
				- 함수가 반환되기 전에 콜백 함수를 실행
					- p()가 반환되기 전에 f()가 실행됨
				- 템플릿 메서드 패턴과 유사하다.
			- 비동기식 콜백 == 지연 콜백
				- 함수가 반환된 후 콜백 함수를 실행
				- 비동기식 옵저버 패턴과 유사하다.
			- addShutdownHook()
				- tomcat의 jvm 종료 가로채기
				- 이거 왜 이렇게 구현함?
			- 템플릿 메서드 패턴과 콜백의 차이는?
				- 동기식에서 둘 다 비슷하다.
				- 하지만 비동기식은 옵저버 패턴과 유사하다.
				- 코드 구현 관점에서는 둘 다 완전하게 다르다.
					- 콜백은 합성 관계를 기반으로 한 객체에서 다른 객체로 전달하는 관계
					- 템플릿 메서드는 상속 관계
	3. 전략 패턴
		- if-else, switch를 피하기 위해서 자주 사용함.
		- 각 알고리즘을 개별적으로 캡슐화하여 이를 서로 교환 가능하게 만드는 것. 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
		- 다형성을 사용하기 때문에 동적으로 분기를 처리할 때 유용하다.
		- 하지만 전략을 계속 추가할 때마다 전략을 '생성하는 쪽'에서의 코드 수정은 불가피하다.
			- 기존 전략을 생성하는 객체에다가 새로운 전략을 넣어주고 매핑하는 작업이 필요하게 됨.
			- 외부 설정 파일, 애노테이션과 리플렉션을 활용하면 이러한 문제를 해결할 수 있다.
		- if-else가 나쁜 코드는 아니다.
			- 분기가 간단하면 사용해도 상관없다.
			- if-else 패턴을 없애기 위해서 전략 패턴을 사용하는 것은 아니다.
	5. 책임 연쇄 패턴
		- filter, interceptor, plugin 등을 개발할 때 자주 사용하는 패턴
		- 여러 개의 수신 객체가 발신된 요청을 처리할 수 있도록, 요청의 발신과 수신을 분리한다. 발신된 요청은 해당 요청을 처리할 수 있는 수신 객체를 만날 때까지 체인을 따라 계속 이동한다.
		- A - B - C ... 이렇게 요청이 차례로 이동하는 모양
			- 각 지나는 객체마다 해당 요청에 자신의 역할을 수행한다.
		- 단순한 기능이라면 차라리 if문을 계속 사용하는 것이 좋을 수도 있다.
			- 하지만 확장하고 코드의 복잡성을 낮추고 클래스를 작게 만들고자 하면 사용할 필요가 있다.
	6. 상태 패턴
		- 일반적으로 사용되는 것은 아님.
		- 복합체 패턴과 약간 유사
		- 상태 머신을 구현하는데 사용. 게임이나 워크플로 엔지과 같은 시스템 개발에 자주 사용.
		- 유한 상태 기계 == 상태 머신
	7. 반복자 패턴
		- cursor pattern이라고도 함
		- 컬렉션을 정해진 순서대로 가져올 때 사용
		- Collection을 구현한 구현체가 필드로 Iterator 구현체를 가지고 있다.
			- Iterator 구현체가 초기화할 때 Collection 구현체를 넣는 방식
			- new ArrayIterator(ArrayList< E > arrayList)
		- 인덱스 방식의 for문이 훨씬 간결한데 왜 반복자 패턴이 필요한가
			- 리스트, 배열은 간결하나 트리, 그래프와 같이 복잡한 데이터 구조에서는 순회 알고리즘을 직접 구현하기 어렵다.
			- 코드의 복잡도를 낮추고 코드를 분할하기 위해서 사용
		- 반복자 패턴의 문제
			- 순회 도중에 요소를 삭제, 추가할 때 문제가 발생할 수 있다.
				- 순회 시 cursor를 사용하기 때문
			- 해결 방법 1
				- 순회 시 요소의 삭제, 추가를 허용하지 않는다.
			- 해결 방법 2
				- 순회 시 기존에 알고 있는 값과 다를 경우 예외를 발생시긴다.
				- Java ArrayList에도 lastRet 변수를 추가해서 삭제할 때 커서와 lastRet을 업데이트해 요소를 삭제함.
		- 스냅숏을 지원하는 반복자 패턴
			- 스냅숏 - 원본 컬렉션의 복사본
			- 원본의 요소가 삭제되어도 복사본은 변경되지 않는다.
			- iterator는 순회할 때 원본 컬렉션이 아닌 스냅숏을 참고해서 순회한다.
			- 순회할 때 원본요소의 데이터가 삭제, 추가되어도 cursor 문제를 방지한다.
		- 시간기반 반복자 패턴
			- 추가된 시간, 삭제된 시간을 기록한다.
			- 추가될 때 삭제 시간에는 Long.MAX_VALUE를 기록한다.
			- 삭제시 삭제 시간을 업데이트한다.
			- 반복자도 snapshotTimestamp를 찍는다.
			- 순회할 때 조건이 addTimestamp < snapshotTimestamp < delTimestamp의 조건을 만족해야 순회 대상에 포함되도록 한다.
	8. 비지터 패턴
		- 어려운 패턴임
		- 가독성도 떨어지고 보수성도 떨어져서 잘 사용은 하지 않는다.
		- 하나 이상의 작업을 객체 집합에 적용하여 객체에서 작업을 분리할 수 있다.
		- 왜 어려운 패턴인가?
			- 대부분 객체지향에서 오버로딩이 결정되는 시간이 컴파일 시간이기 때문.
			- 굳이 비지터 패턴이 필요한지 생각해볼 필요가 있다. 다른 방법으로도 해결할 수 있음
		- double dispatch
			- 객체의 실행 시간 유형에 따라 실행할 객체의 메서드가 결정되고,
			  메서드의 실행 시간에 따른 매개변수 유형에 따라 객체에서 실행할 메서드가 결정된다.
				- 즉, 메서드 파라미터에 상위타입 형태로 전달되어도 오버로드가 동작? 하는듯
			- single dispatch
				- 객체의 실행 시간 유형에 따라 객체에서 실행될 메서드가 결정되지만, 어떤 객체의 메서드가 실행되는지를 결정할 때는 메서드 매개변수의 컴파일 시간 유형에 의해 결정됨.
					- 즉, 오버로드를 할 때 상위타입으로만 구체타입을 결정할 수가 없다.
					- 컴파일 때 메서드 시그니처를 통해서 어떤 메서드가 호출되는지 결정한다.
	9. 메멘토 패턴
		- 데이터 손실 방지, 취소, 복구에 사용된다.
		- 시나리오 범위가 명확하고 제한적.
		- 대용량 객체의 백업과 복구를 위해 메멘토 패턴을 적용하면 시간과 공간을 효과적 절약 가능.
		- snapshot pattern이라고도 불린다.
		- 캡슐화 원칙을 위반하지 않는다는 전제하에서, 객체의 내부 상태를 획득하고, 이 상태를 객체의 외부에 저장하여, 객체를 이전 상태로 복구할 수 있도록 한다.
	10. 커맨드 패턴
		- 요청을 객체로 캡슐화하여, 다른 객체를 다른 요청, 대기열 요청, 로깅 요청과 함께 매개변수로 전달할 수 있도록 하며, 취소 가능한 작업으 지원.
		- 핵심은 '함수를 객체로 캡슐화 한다.'
			- 자바에서는 객체로 감싸야 한다.
		- 전략 패턴과 유사한 모양인데, 무슨 차이?
			- 전략패턴 - 각각의 전략은 동일한 목적을 가지나 서로 다른 구현 방식을 사용. 서로 대체가 가능
			- 커맨더 패턴 - 각각의 명령은 서로 다른 목적을 가지는 다른 처리 방식을 가지고 있으며 대체할 수 없다.
	11. 인터프리터 패턴
		- 언어에 대한 문법을 정의하고, 이 문법을 처리하기 위한 인터프리터를 정의한다.
			- 언어 - 정보를 전달할 수 있는 수단
			- 문법 - 언어로 이루어진 정보를 해석하기 위한 규칙
			- 즉, 인터프리터는 전달받은 정보를 해석하는 역할을 담당한다.
		- 예제
			- 계산기 로직을 구현해야 함.
			- 계산을 위한 로직이 담긴 객체 (+,-,*,%)
				- 이 객체를 해석하는 인터프리터를 정의
				- 클아이언트는 이걸 사용만 한다.
	12. 중재자 패턴
		- 잘 사용하지 않음. 시나리오가 제한적
		- 옵저버 패턴과 유사함.
		- 객체 컬렉션 간 상호 작용을 캡슐화하는 별도의 중재자 객체를 정의하고, 객체 간의 직접적인 상호 작용을 피하기 위해 상호 작용을 중재자에게 위임
			- pub sub에서 message broker가 해당 역할?
			- 직접 해당 객체에게 메시지를 보내는 것이 아니라 중재하는 객체에게 메세지를 보내고 그걸 중재자가 전달하는 것.
		- 상호작용이 매우 복잡한 경우에만 유용하다.
### References
---
[]()