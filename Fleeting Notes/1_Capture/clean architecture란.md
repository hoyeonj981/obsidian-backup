created at : 2024-02-28 11:05

#### tags

#Design #Architecture 

--- 

- 기존 아키텍처의 문제점
	- 데이터 베이스를 먼저 생각해서 설계를 한다.
	- 동시 작업하기가 어렵다. (영속성 계층 -> 서비스 -> 컨트롤러 순서 개발)
		- 이건 절차지향적인 코드의 문제
		- 레이어드 아키텍처가 절차지향적인 사고를 유도한다.
		- 테스트하기가 어렵다.
			- 빠른 유닛 테스트가 어려움
	- 확장성이 떨어진다.
		- 기능을 분리하기가 어렵다.
- 그렇다면 클린 아키텍처 책에 나온대로 개발해야 하는가?
	- 그건 아님
	- 클린 아키텍처 구조에 따라 개발하면 코드를 찾을 때 패키지 구조에 따라서 찾기만 하면 된다.
		- 유지보수, 의사소통, 개발이 수월해짐

- 클린 아키텍처 - 모듈러 모노리스 이 둘은 어떤 관계?
	- 헥사고날 <-> core, database, api, batch 이런 식의 아키텍처 구조는 무슨 차이점?
	- 이런저런 자료를 보면서 이름만 다르지 구조는 비슷하다는 느낌이 든다.
	- 완벽하게 도메인을 고립시키든가, 어차피 자바나 코틀린으로 작성된 코드는 스프링을 사용하니까 스프링 기술까지는 포함하던가 등 적절한 트레이드오프가 있는 것 같다.
- 격리를 위해서 적절히 접근 제어자를 선택하라
	- package-private, public, private, protected
- 의존성 역전을 활용하라
	- 애플리케이션 계층에 인터페이스를 두고 어댑터에 해당 인터페이스를 상속해서 구현한 클래스를 둔다.

- 유스케이스가 따르는 단계
	1. 입력을 받는다. (input, controller)
		- 이 때 반환하는 값을 dto로 따로 포장할 것인가, 아니면 도메인 모델을 그대로 반환할 것인가?
		- 입력으로 들어오는 값을 검증
	1. 비지니스 규칙 검증 (validate, service)
		- 직접 get해서 모델을 조작하기 보단, 모델에게 위임한다.
			- 근데 필요에 따라서 도메인 모델에서 꺼낸 다음 검증하는 것도 가능함.
		- 그 외 외부 저장소나 락이나 이런 것을 관리하는 곳
	2. 모델 상태 조작 (execute)
		- 객체지향적으로 작성할 경우, 도메인 객체들이 서로 협력해서 변경이 이루어 진다.
		- 모델에 조작이 일어날 때도 검증해야 할까?
	1. 출력을 반환 (output)
		- 이 때 반환하는 값을 dto로 따로 포장할 것인가, 아니면 도메인 모델을 그대로 반환할 것인가?
			- 도메인 모델을 외부로 노출하지 말라는 글을 읽은 적이 있다. dto로 따로 포장하는 것이 좋겠다.
				- 너무 클래스가 많아서 복잡하지 않을까?
- 유스케이스 구현하기
	1. 도메인 모델을 구현한다. (객체지향적으로)
	2. 유스케이스
- 빌더 패턴? 생성자?
	- 필드 값이 많을 수록 생성자가 복잡해짐
	- 빌더 패턴을 사용하는 것이 좋을까?
	- 빌더 패턴은 실수를 유발할 수 있다. (컴파일 에러로 검출 x)
	- 편하고 기본제공하는 생성자를 사용하자
	- 요즘 ide는 생성자 호출 시 파라미터명을 힌트로 제공한다.
- 하나의 커멘드 객체를 이곳저곳에서 사용할 경우
	- 필요없는 필드 값은 null일 수도 있다.
		- 이건 code smell
	- 필드값에 따라 검증하는 로직이 계속 추가된다.
- 빈약한 vs 풍부한 도메인
	- 빈약한 : service에 비지니스 로직이 대부분
		- 절차적인 로직
		- 직관적
		- 테스트하기 어려움 (목을 쓰거나, 테스트용 환경을 구축할 필요가 있음 -> 느림)
		- 거대해질 수록 유지보수하기 어려움
	- 풍부한 : 도메인 엔티티에 로직이 대부분
		- 객체지향적
		- 직관적이지 않음
		- 단위 테스트하기 편함 (물론 객체지향적 코드로 잘 작성했을 경우)
		- 유지보수하기 편하다. (상대적임, 회귀테스트를 통한 리팩토링)

- 웹 어뎁터의 책임
	- HTTP 요청을 자바 객체로 매핑 (직렬화)
	- 권한 검사 (서블릿 필터 혹은 스프링 시큐리티)
	- 입력 유효성 검증
		- 이거 usecase 쪽에서 책임진다고 했는데?
			- 그것과 다른 유효성 검증 (요청으로 온 것을 검증)
	- 유스케이스 호출 (서비스 호출)
	- 유스 케이스의 출력을 http로 매핑 (역직렬화)
- 역할에 따라 컨트롤러를 나눠야 한다. (xxxController로 퉁 치지말라)
	- 클래스에 코드가 적을 수록 파악하기 쉽다.
	- 클래스의 역할이 작을 수록 테스트 코드를 통해서 대략적인 흐름 파악이 쉽다. (프로덕션 코드가 파악하기 힘들어서 테스트 코드를 열었는데 그것도 길 경우 파악하기 힘들다.)
	- 하나의 클래스는 재활용을 촉진한다.
		- 즉, 클래스 메서드들이 하나의 공통된 클래스를 자꾸 사용하는 경우가 있을 것이다.
		- 분리하고 싶어도 강하게 결합되어 분리하기 까다로울 순간이 올 수 있다.
	- 가능하다면 유스케이스를 반영해서 컨트롤러를 쪼개자
		- 요청, 응답을 다룰 때 객체로 다뤄도 상관없고 원시값도 상관없음.

- 영속성 어뎁터
	- 애플리케이션에게 사용되는 입장
	- 책임
		- 입력을 데이터베이스 포맷으로 매핑 (jpa, mybatis)
		- 입력을 데이터베이스로 보낸다. (mysql, redis 등)
		- 데이터베이스 출력을 애플리케이션 포맷으로 매핑 (entity to domain)
			- 
	- 출력하는 도메인 모델은 애플리케이션 패키지 안에 있어야 한다.
	- 데이터베이스 연산을 위해서 '커다란' 리파지토리 객체는 필요 없다.
		- 모킹할 때 어떤 메서드를 모킹해야 할지 알기 힘들다.
		- 리파지토리 전체 메서드가 모킹되었다고 착각할 수 있다.
		- 오직 자기 자신만 알면 되는 특화된 인터페이스가 더 좋다.
	- 바운디드 컨텍스트 간의 경계를 명확하게 구분하고자 한다면 영속성 어뎁터를 바운디드 컨텍스트마다 가지고 있을 것.
- 영속성 어뎁터에서 트랜잭션 경계는?
	- 애플리케이션 계층에서 문제가 있을 경우 롤백이 되어야 한다.
	- 근데 영속성 어뎁터는 애플리케이션 계층을 알지 못한다.
	- 일반적으로 service에 @transactional을 붙여서 사용함.
	- 서비스를 순수한 자바코드로 유지하고 싶다면 이것을 apsectJ AOP를 사용해서 위빙할 수 있음.

- 용어 중간 정리
	- 컨트롤러 인터페이스 : usecase
		- 조회 : query
		- 데이터 조작 : command
		- dto는 경우에 따라서 추가. 원시타입도 상관없음
		- 도메인 엔티티는 외부로 노출하지 말 것
		- 컨트롤러는 가능하다면 usecase에 맞춰 분리할 것
		- 컨트롤러는 adapter.in 패키지 안에 존재한다.
	- 영속서 인터페이스 : port
		- 도메인 엔티티 <-> 영속성 엔티티 : mapper가 담당
		- transaction 범위는 애플리케이션에서 담당
		- port 인터페이스는 가능하다면 기능에 특화된 모양을 유지할 것. (load, store 등)
		- 바운디드 컨텍스트를 경계마다 하나씩 어뎁터를 가질 것

- 테스트 피라미드
	- 단위 - 통합 - 인수(시스템)
	- 위로 갈 수록 테스트비용이 증가함.
		- 깨지기 쉽고, 느리다
	- 테스트가 비싸진다 -> 테스트 커버리지를 낮게 잡아라
		- 새로운 기능보다 테스트를 위해서 시간을 더 쓰게 됨.
- 단위 테스트
	- 도메인 엔티티 테스트
		- 가장 간결하고 기본 단위 중 하나
	- 도메인 유스케이스 테스트
		- 이건 단위 테스트인가?
			- 통합테스트에 가까움. (의존성의 상호작용 검증 필요)
			- 목을 사용하기 때문에 의존성 관리가 쉬움. 단위와 통합 사이 어딘가
		- 계좌 조회 후 결제시 잠금을 거는 것을 확인할 필요가 있음.
			- lock이 걸리는 것만 확인할 경우 (상호작용만 검증), 변경에 취약해짐. -> 코드 변경시 리팩토링 필요
- 통합테스트
	- mockMvc를 통해서 테스트
		- HTTP 프로토콜 호출을 테스트하는 것은 아님.
			- 어차피 프레임워크가 이미 테스트했을테니
	- 이것도 모킹을 하기 때문에 의존성을 가지는 단위 테스트랑 다를 바가 없지 않나?
		- 프레임워크에서 JSON 매핑, http 입력 검증 등 다양한 일을 어노테이션으로 간단하게 처리중.
		- 즉, 사실상 통합 테스트를 안보이게 하고 있다.
	- 스프링 프레임워크를 사용하면 사실상 입력을 스프링에 강하게 의존하고 있는 형태 아닌가? 그렇다면 스프링 프로젝트에서 입력을 굳이 usecase로 분리할 필요가 있는가?
	- 영속성 어뎁터 통합테스트
		- h2나 컨테이너나 테스트용 디비 등 이것저것을 사용해서 검증
- 시스템 테스트
	- 전체 시스템을 띄운 뒤 API 요청을 보내는 테스트
	- 여기서도 어쩔 수 없이 모킹해야 할 경우도 있다.
- 테스트 커버리지
	- 라인 커버리지
		- 별로 안 좋음
	- 테스트는 배포해도 될 만큼 신뢰할 수 있다면 뭐든 상관없다.
		- 도메인 엔티티는 단위 테스트로 커버
		- 유스 케이스를 구현할 때 단위 테스트로 커버
		- 어댑터는 통합 테스트로 커버
		- 사용자가 취할 수 있는 애플리케이션 경로는 시스템 테스트로 커버

- 어댑터에 있는 매핑 클래스
	- 어차피 대부분 crud인데 왜 굳이 이런 복잡한 코드를 써야 하나vs 두 계층이 하나의 엔티티를 사용하니 강한 결합이 된다.
	- 하나의 도메인 엔티티를 널리 사용할 경우
		- 직렬화 때문에 애노테이션을 추가해야 함.
		- 영속성과 웹의 요구사항을 반영한 코드가 엔티티에 추가됨.
			- 단일책임 위반
	- 양방향으로 매핑할 경우 (웹 <-> 도메인 <-> 영속성)
		- 너무 많은 보일러플레이트 생성
		- 매핑 라이브러리를 사용할 경우 디버깅이 어려움 (리플렉션, 제네릭 등)
	- 완전 매핑을 할 경우 (웹<-> dto <-> 도메인 <-> dto <-> 영속성)
		- 더 많은 보일러플레이트
		- 유스케이스가 명확해짐 (뭘 담고 뭘 요청하는지 뭘 받는지 확인하기 쉽고 변경도 용이함)
		- 오버헤드를 넘는 명확한 경계가 있을 수도 있고 없을 수도 있다. 오버헤드를 충분히 감내할 수 있는가?
	- 단방향 매핑 (dto, domain이 하나의 인터페이스를 상속할 경우)
		- getter와 같은 메서드를 제공해서 캡슐화, 풍부한 행동을 구현할 수 있음.
		- factory가 경계를 나갈 때 도메인 객체를 재구성해서 전달해줄 수 있음.
	- 결국 상황에 따라 다 다르다. 적절한 것이 있지 최고의 것은 없다.

- 설정 컴포넌트
	- 책임
		- 웹 어댑터 인스턴스 생성 (빈 등록, 팩토리)
		- http 요청이 실제 웹 어댑터로 전달되는 것으 보장 (mvc에서 담당)
		- 유스케이스 인스턴스 생성 (빈 등록, 팩토리)
		- 영속성 인스턴스 생성 (빈 등록, 팩토리 )
		- 유스케이스에 영속성 어댑터 인스턴스 제공 (application context)
		- 영속성 어댑터가 실제 db에 접근할 수 있도록 보장 (application 설정파일 혹은 빈 등록)
	- 사실상 단일책임을 위반 (애플리케이션의 전체를 알고 있다.)
	- 다른 부분이 멀쩡히 동작하기 위해서 어쩔 수 없다.
	- 프레임워크를 사용할 경우 해당 프레임워크에 상당히 의존하게 된다.

- 경계를 명확하게 하기
	- 접근 제한자
		- 기본적인 도구
		- 패키지 내의 클래스가 너무 많아지면 결국 하위 패키지를 만들게 되는데, 이 때 package-private을 사용할 수 없다.
	- post compile check
		- 컴파일 이후에 도구로 확인하기
		- archunit
	- build artifact
		- 멀티 모듈로 구성하기
		- gradle, maven 등
		- 순환 의존성을 경계할 것.

- 지름길 피하기
	- usecase 2개가 1개의 dto를 공유할 경우
		- 변경 시 2개 다 영향을 받는다.
		- usecase가 어떻게 진화할 지 알 수 없다.
			- 일단 분리해서 시작하는 것이 좋다. (똑같은 속성을 가질지라도)
	- 도메인 엔티티를 공유할 경우ㅖ
		- 도메인 엔티티에게 로직이 위임되면서 풍부한 도메인이 된다.
			- usecase가 변경될 때 풍부한 도메인도 같이 영향을 받을 것이다.
	- 인터페이스 없이 그냥 바로 service를 사용하는 경우
		- 하나만 있다면 상관이 없다.
		- 인터페이스가 아키텍처를 강제하게 한다.
			- 의도와 다른 메서드를 호출할 일이 없다.
			- 진입점을 명확하게 확인할 수 있다.
	- 서비스 건너 뛰기
		- 로직이 모두 도메인 안에 들어간 경우
		- 바로 영속성 객체로 반영
		- 요구사항이 간단할 경우 그럴 수 있다.

- 궁금증
	- 멀티모듈과 클린아키텍처는 어떻게?
		- api, core, config, batch 이런식으로 기능으로 분류할 경우
			- api 안에 usecase를 상속하고 이런 구조?

- 왜 아키텍처를 신경써야 하는가?
	- 아키텍처를 통해 제약 사항을 정의하고 시스템 파악을 용이하게 한다.
	
- 헥사고날 다시 정리
	- 도메인
		- 해결해야 할 문제 영역
		- 엔티티
			- 문제 영역을 모델링하고 여기서 식별된 것들 중 객체로 옮기는데, 그 중에서 식별자를 가지는 객체.
				- 어떻게 모델링할 것인가?
					- UML을 사용해서 객체 기반, 행동 기반 등 다양한 방법들이 있다.
			- 식별할 수 있는 고유 값을 가진 객체
			- attributes가 바뀌어도 식별자가 같으면 같은 엔티티다.
				- post 객체 안에 title이 있는데 title이 바뀌어도 id가 같으면 같은 엔티티다.
			- 값 객체 or 엔티티로 조합할 수 있음
			- 식별자
				- 데이터베이스에 위임 (auto increment) 방법도 있으나 외부 시스템과 결합하게 됨.
				- UUID가 대표적인 해결책
					- 성능 이슈가 존재할 수 있다. (인덱스 문제, 공간 문제)
			- 비지니스 로직을 포함하고 있다.
				- 가능하다면 기술적인 요구사항과 관련이 없어야 한다. (비지니스 문제 영역에 대한 로직이기 때문)
		- value object
			- 값만 가지고 있는 객체
			- 불변
			- 단순히 primitive, reference type으로 표현하지 않고 객체로 감싸서 의도를 명학하게 나타낼 수 있다.
			- 무엇을 값 객체로 만들어야 하는가?
				- 로직을 가질 필요가 있는가?
					- Long 타입으로 연산하는데 해당 값을 연산하는 곳이 이곳저곳에서 빈번히 등장한다.
				- 언어에서 기본 제공하는 타입으로는 의미가 모호한가?
					- money를 가지는 객체가 있는데 달러 <-> 엔화로 환전하는 연산이 빈번할 경우
			- 값 객체로 추상화는 어디까지?
				- 너무 큰 의미로 추상화할 경우 응집도가 떨어짐
				- 좁은 범위로 추상화하는 것이 적절할 수도 있다.
					- BigDecimal을 money로 쓰는 것보다 ItemPrice, RefundAmount, DeliveryFee 이런 식으로 구체적이고 좁은 의미로 추상화하면 잘못 쓰일 경우도 줄일 수 있고 의도도 명확하고 객체가 가진 책임도 명확해짐
			- validation을 포함하고 있다.
				- 경우에 따라 entity에서 validation 로직을 대신 처리할 수도 있다.
		- aggregate
			- entity + vo
			- root entity가 있음
			- 이 안에 있는 객체는 동일한 혹은 유사한 생명주기를 가진다.
			- 트랜잭션 적용 범위로 설정할 수 있다.
			- 가능한 작은 바운더리로 구성하는 것이 좋다.
				- 애그리게잇은 entity + vo들의 집합이다.
				- 너무 많으면 메모리를 많이 차지한다.
				- gc에 의한 퍼포먼스 이슈가 발생할 수도 있다.
			- 작은 애그리게잇은 root entity + 여러 vo로 구성
			- 서로 다른 애그리게잇은 id를 통해 식별
			- root entity는 child entity에 대한 변경을 수행해야 한다.
				- 다른 애그리게잇에서 root entity를 무시하고 child entity에 접근할 수 없다.
	- 헥사고날
		- 도메인
			- 비지니스 로직, 객체지향적 설계, DDD
			- 해당 엔티티에 부합하는 동작인가? 아닐 경우 도메인 서비스에서 처리
		- 도메인 서비스
			- 한 애그리게잇으로 표현할 수 없는 로직들 (여러 애그리게잇이 필요함, 특정 애그리게잇으로 분류하기 애매함)
			- 일반적으로 상태를 비저장함.
			- 본질적으로 도메인과 관련된 로직이 포함된다.
		- 애플리케이션
			- usecase 인터페이스
				- 소프트웨어의 동작을 추상화
				- 동작에 대한 설명을 나타냄 (SendMoneyUseCase)
			- 애플리케이션 서비스 (usecase의 구현체)
				- entity, vo, 도메인 서비스의 흐름을 조절함
				- ui, 영속성, 외부 시스템과 상호작용을 담당
			- command, query
				- dto
				- command는 수정, 생성, 삭제 등을 위한 정보를 전달
				- query는 조회만 담당
				- 나누면 무슨 장점?
			- in, out port 인터페이스
				- in : 어뎁터에서 입력되어 어떤 데이터가 출력되는 지 인터페이스로 결정 (주로 클라이언트 요청 관련)
				- out : usecase에서 어떤 데이터가 입력이 되어 출력이 되는지 결정 (주로 영속성 관련)
		- 어뎁터
			- in과 out의 구현체들의 모임
			
- 도메인 서비스, 애플리케이션 서비스 이걸 나눌 필요가 있는가?
	- 이렇게 나눌 필요가 있나?
		- 굳이 나누자면 도메인 로직을 포함하냐 안하냐
			- 도메인 서비스 : 한 애그리게잇으로 표현하기 모호한 entity, vo 로직들, 여러 애그리게잇이 필요한 도메인 로직을 처리함
			- 애플리케이션 서비스 : ui, 영속성, 외부 시스템과 상호작용, entity, vo의 흐름 조절 (트랜잭션 처리나 lock 등)
		- 하지만 이걸 나눠서 얻는 이점이 무엇인가?
			- 애플리케이션 서비스가 얇은 모양이 된다.
				- 중간에 중재자 역할만 담당
			- 중요한 도메인 개념인데, entity나 vo로 나누기 모호하다면 도메인 서비스로 빼서 명확하게 나타내는 것이 좋다.
			- 하지만 간단한 로직일 경우 굳이 도메인 서비스보다 애플리케이션 서비스에 두는 것이 좋다.
	- 차이점
		- 도메인 서비스는 엔티티 내부에 주입할 수 있다.
		- 도메인 서비스는 도메인 로직을 포함할 수 있다.
		- 도메인 서비스는 상태를 저장하지 않는다. (입력을 받아 그 입력으로 처리한 뒤 그 결과를 반환만 함)
			- 상태를 가지지 않는다는 것이 repository나 다른 서비스가 없다는 것이 아님.
		- 애플리케이션 서비스는 주입할 수 없다.
		- 애플리케이션 서비스는 중간에서 흐름조절, 외부와의 상호작용을 담당한다.

- specification pattern
	- 객체로 구현된 Predicate 와 비슷하다.
	- 결합해 사용할 수 있는 구조로 작성이 되어 있다.
	- 만약 정책 패턴이 없다면?
		- 도메인 서비스에서 검증 로직을 수행할 때 엔티티의 세부 사항이 자꾸 외부로 노출이 된다.
		- 단순한 검증인 경우 상관이 없음
			- 단, A, B, C, D ... 이렇게 만족해야 할 조건이 늘어날 수록 엔티티의 세부사항이 자꾸 밖에 노출될 수 밖에 없다.
		- 검증 로직을 객체로 만들고 이걸 연결할 수 있게 구성해서 SRP, OCP를 만족한다.
	- 언제 사용하는 것이 좋을까?
		- 검증 로직이 필요하고 계속해서 추가될 여지가 있는데 이걸 도메인 서비스에서 계속 추가할 경우
		- 검증 로직이 서로 조합해서 또 다른 로직을 만들 경우
			- if A then B then C ... 이런식
		- 검증 로직에서 엔티티의 세부 사항이 노출되는 것을 캡슐화하고 싶을 경우

- policy pattern
	- 전략 패턴과 유사함
	- 전략 패턴을 enum으로 관리하는 것이 더 효율적?
	- 전략패턴을 보면 상속을 통해서 사용하던데, 결국 하드코딩된 방법을 사용하는 것이 아닐까
	- 결국 어떤 정보를 바탕으로 런타임에 선택이 되어야 쓸모가 있는 패턴으로 생각된다.

- usecase
	- 여기서 설명하는 usecase는 UML에서 나오는 usecase인가?
		- 설명하는 것을 보면 UML의 usecase와 동일하다.
	- 헥사고날 아키텍처에서 usecase를 정의할 때 왜 interface로 정의하는가
		- usecase의 목표를 달성하는 다양한 방법 제공
		- 구현보단 추상적 개념에 의존하기

- 만들면서 배우는 클린 아키텍처 vs 헥사고날 아키텍처 설계와 구현의 차이점
	- 만들면서
		- adapter에 구현체가 들어간다.
		- port에 인터페이스(usecase, port)가 존재한다.
		- application에 서비스 구현체가 존재한다.
			- 굳이 도메인 서비스를 나누지 않았다.
			- 애초에 도메인 서비스로 나눌 요소가 없는 것 같다.
			- 만약 외부와 상호작용을 하기 위한 중간 계층으로 service를 사용한다면 애플리케이션에 두는 것이 올바르다고 생각. (말 그대로 애플리케이션 동작이기 때문에
	- 헥사고날
		- port 안에 인터페이스와 구현체가 존재.
			- usecase를 명확하게 구별하기 위함인가?

- 클린 아키텍처 (헥사고날, port and adapter pattern, onion)
	- 핵심 로직과 세부 사항을 명확하게 구분한다.
	- 세부사항에 대한 결정을 미룰 수 있어야 한다. (세부사항을 몰라도 개발은 진행됨)
	- 이걸 가능하게 하는 방법이 DIP
		- 이게 핵심인 듯?
	- 이렇게 개발하면 테이블 설계를 고민을 미루고 일단 개발할 수 있다.
		- dip에 의해 test double를 만들어 테스트 하기 용이하다.
	- 근데 명확한 규칙이란 것이 없는 것 같다.

- 포트와 어뎁터, usecase의 차이
	- usecase
		- UML에서
			- 사용자 관점에서 시스템을 모델링하는 방법 - usecase 다이어그램
				- 여기서 시스템이 제공하는 단위 기능이 usecase
				- 즉, 시스템이 제공하고자 하는 기능을 추상화하고 명시적으로 나타내서(아키텍처에) 프로그램이 어떤 의도를 가지고 있는지 바로 알 수 있다.
			- 예
				- 사용자는 게시글을 생성, 수정, 삭제를 할 수 있다.
					- 게시글에 대해 사용자가 3가지 usecase를 사용할 수 있다.
					- 게시글에 대한 3가지 작업을 하는 usecase 인터페이스를 생성한다.
	- 포트
		- 입력 포트
			- usecase의 구현체
			- 도메인과 애플리케이션 사이의 경계에 존재
			- 접근하는 어뎁터는 usecase를 사용하고 inputPort는 해당 usecase를 구현해서 사용자가 도메인 로직을 수행할 수 있게 한다.
			- 직접적인 도메인 로직을 수행하지는 않고 애플리케이션 계층에서 필요한 작업 수행
				- 트랜잭션, 락, 외부 시스템과 연동, 도메인 객체 흐름 관리 등
			- 출력 포트도 애플리케이션에 속하므로 해당 port를 사용할 수 있다.
				- 영속성, 외부 시스템 연동 등
		- 출력 포트
			- 어뎁터가 구현할 인터페이스
			- 외부 데이터를 처리하려는 애플리케이션의 의도를 나타냄
			- 데이터를 조회할 때 어떤 것을 원하고 반환하는지, 저장은 어떻게 하는지 등
			- 스프링 data에서 JpaRepository와 같이 하나로 묶어 쓸 수 있는 기능을 제공한다.
				- 인터페이스를 나누는 이유가 test double로 교체하기 위함인데, 상속으로 기능을 확장하기 때문에 test double로 활용하기 어렵지 않을까?
				- 도메인에 속한 repository에 데이터베이스 개념이 추가된다.
	- 어뎁터
		- 시스템의 기능을 사용할 때 접근하는 구현체들의 모임
		- 가장 밖의 경계에서 상호작용 담당.
		- 대부분 프레임워크를 사용하기 때문에 프레임워크 위에 구현된 코드다.
		- 왜 핵사고날 책에서는 adapter를 구현할 때 adapter 패키지 안에 또 인터페이스를 만들었을까?
			- 일반적으로 애플리케이션에 정의된 output을 구현하는 클래스가 adapter에 위치함
			- input 어뎁터가 CLI, REST를 지원하니까 둘에서 공통으로 쓰는 부분을 추상화함. (추상 클래스 사용)
			- 그래서 내부 코드에 usecase가 사용됨.
				- 어덥테 inport 구현체가 usecase를 사용하는 입장
			- inport는 usecase 인터페이스 구현체
				- application 패키지 안에 존재
				- 스프링으로 치면 service 구현체가 여기에 존재
			- usecase를 사용하는 것이 inport adapter, 런타임에는 inport 구현체가 동작한다.
				- adapter 패키지 안에 존재
				- 스프링으로 치면 controller가 여기에 존재
			- outport 인터페이스가 정의되고 inport 구현체가 사용한다.
				- application 패키지 안에 존재
				- 스프링으로 치면 repository 인터페이스가 존재?
					- domain 안에 repository를 넣는데 application에 넣는 outport는 올바른가?
						- domain이 infrastructure에 의존하면 안 된다라는 의미이다.
						- port와 adapter로 나누면 결국 저수준은 고수준에 의존하게 된다.
						- 즉, domain -> infrastructure 모양은 이미 해결됨.
			- outport 구현체는 adapter이다.
				- adapter 패키지 안에 존재
				- 스프링으로 치면 repository 구현체가 여기에 존재

- monolith vs microservice
	- monolith
		- 통신 오버헤드가 적다. (굳이 외부에 서비스를 호출하기 위한 오버헤드가 없다.)
		- 시스템에서 생성된 로그가 중앙화됨. (문제가 어디서 터졌는지 확인하기 쉽다.)
	- microservice
		- 일부 데이터가 네트워크를 통해서 전달된다. (오버헤드 발생)
		- 문제 발생 지점을 찾기 힘들다. (로그 중앙화 필요)
		- 패키지가 작아 컴파일 시간이 상대적으로 빠르다.
		- 다른 서비스와 달리 독립된 배포 단위를 가질 수 있다.
		- 언어적 제약이 없다.

- 드라이빙, 드리븐 오퍼레이션
	- 드라이빙
		- 헥사고날 애플리케이션의 행위를 유도하는 입력 어뎁터
		- API를 노출
	- 드리븐
		- 데이터를 외부로 내보내는 역할
		- DB, 메시징 브로커, 웹 소켓 등

- JPMS
	- se 9 이전
		- 의존성을 처리하는 유일한 메커니즘 classpath 매개변수
		- classpath 매개변수는 JAR 형식으로 의존성을 넣는다.
		- 특정 의존성이 어떤 JAR에서 왔는지 확인하기 힘들다.
		- 같은 패키지 안에 같은 이름을 가진 두 클래스
			- me.peppermill.aaa.TestClass (JAR A)
			- me.peppermill.bbb.TestClass (JAR B)
			- 먼저 로드된 JAR에 의해 다른 하나가 가려진다. (shadowing)
		- JAR 파일은 public 외에는 액세스 제어 방법이 없었다.
	 - se 9 이후
		 - module-info.java에서 서로 다른 모듈 사이에 액세스를 제한할 수 있다.
		 - 새로운 기능을 배포할 때 부분 컴파일만 하면 된다.
		 - 클라우드 환경에서 작은 자바 런타임을 사용하면 컴퓨팅 리소스를 줄일 수 있다.
### References
---
[clean architecture example - github](https://github.com/mattia-battiston/clean-architecture-example?tab=readme-ov-file)
[멀티모듈 설계 이야기 - blog](https://techblog.woowahan.com/2637/)
[우아한 모노리스 - slideshare](https://www.slideshare.net/arawnkr/ss-94475606)
만들면서 배우는 클린 아키텍처
헥사고날 아키텍처 설계와 구현
[Coupang 마이크로서비스 아키텍처로의 전환 - blog](https://medium.com/coupang-engineering/how-coupang-built-a-microservice-architecture-fd584fff7f2b)
[실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 1: 효율적인 Mock Test](https://tech.kakaopay.com/post/mock-test-code/)
[rich-domain-model](https://dev.to/kirekov/rich-domain-model-with-hibernate-445k)
[tactical ddd](https://learn.microsoft.com/ko-kr/azure/architecture/microservices/model/tactical-ddd)
https://enterprisecraftsmanship.com/posts/domain-vs-application-services/
https://laswonho.medium.com/domain-service-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-334aad46ac59
https://www.youtube.com/watch?v=g6Tg6_qpIVc
https://softwareengineering.stackexchange.com/questions/396151/which-layer-do-ddd-repositories-belong-to