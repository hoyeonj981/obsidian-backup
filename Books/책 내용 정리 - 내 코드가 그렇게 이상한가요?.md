created at : 2024-07-15 11:17

#### tags

#CleanCode

--- 

- Part 2: 설계 첫 걸음
	- 의도를 분명히 전달할 수 있는 이름 설계
	- 목절별로 변수를 따로 만들어 사용하기
		- 재할당하지 말기
	- 의미있는 것을 모아 메서드로 만들기
	- 관련 데이터와 로직을 클래스로 모으기
		- 응집도를 높힌다.
		- 중복 코드를 줄인다.
			- 로직을 수정할 때 여기저기 찾아다니는 수고가 줄어든다.

- Part 3: 클래스 설계 : 모든것과 연결되는 설계 기반
	- 클래스 단위로도 잘 동작하도록 설계하기
		- 데이터 클래스(ex : dto)
			- 데이터 클래스는 변수를 조작하는 로직이 외부에 구현되어 있다.
				- 중복 코드가 발생할 수 있음.
				- 수정할 때 중복 코드 부분은 그대로 둘 수도 있음
				- 초기화 작업도 자기 자신에게 없을 수도 있다.
	- 성숙한 클래스로 성장시키는 설계 기법
		1. 생성자로 확실하게 정상적인 값 설정하기
		2. 데이터는 데이터를 가진 쪽에서 계산하기
		3. 불변 변수를 만들어서 변경을 방지하기
			- 값을 수정할 필요가 있다면 차라리 새로운 인스턴스로 만들기 (return new ...)
		4. 매개변수, 지역변수도 불변으로 만들기
			- 문제가 발생했을 때 추적하기 쉽다.
		5. 엉뚱한 값을 전달받지 않도록 매개변수를 잘 설정하기
			- void add(int value)
				- 부적절함. value가 어떤 값으로 들어올지 알 수 없다. 의미가 모호함.
			- void add(Money money)
				- 적절함. 엉뚱한 값이 들어올 수 없다. 의미가 명확하다.
		6. 의미없는 메서드를 추가하지 않기
			- 금액을 구할 때 과연 '곱셈 메서드'가 필요한가?
				- 경우에 따라 다를 수 있다. 필요 없다면 '미리' 추가하지 않는다.
		- 잘 설계된 클래스는 단위 테스트를 작성하기 쉽다.
			- 만약 로직이 너무 단순해서 굳이 모을 필요가 없다면?
				- 굳이 도메인 계층이 필요할까?
				- 도메인은 그냥 데이터만 담고 있는 클래스로 만들 수 있다.
				- 대부분 로직이 service에만 있다.
				- transaction script pattern
				- 빠르게 개발하고 직관적이다. 장기적으로 부적절하다.
					- 유지보수가 까다롭다.
					- 테스트를 작성하기 힘들다.
					- 리팩토링하기 어렵다.
		- 클래스 설계란 인스턴스 변수가 잘못된 상태에 빠지지 않게 하기 위한 구조를 만드는 것
		- 디자인 패턴을 활용하라.

- Part 4: 불변 활용하기 : 안정적으로 동작하게 만들기
	- 재할당
		- 재할당은 언제 어떻게 변경되었는지 추적하기 어렵게 만든다.
	- 가변으로 인해 발생한 의도하지 않는 영향
		- 이곳저곳에 전달하다 보면 의도하지 않게 영향이 전파됨
		- 멀티 스레드 환경에서 데이터 일관성을 보장할 수 없음.
		- side effect가 발생할 수 있다.
	- 불변의 장점
		- 다른 곳에서 재할당을 할 수 없다.
		- 함수의 영향 범위를 한정할 수 있다.
		- 예기치 못한 동작을 막을 수 있다.
	- 불번과 가변을 어떻게 다루어야 할까?
		1. 기본적으로 불변으로 만들기
		2. 가변이 필요한 곳은 성능이 중요한 경우
			- 리소스를 최대한 아껴야 할 경우
			- 대량의 데이터를 빠르게 처리하는 경우
			- 이미지를 처리하는 경우
			- 스코프가 국소적인 경우(ex: 반복문 내부의 지역변수)
		3. 코드 외부와 데이터 교환은 국소화
			- IO 작업은 외부 작업이면서 제어할 수 없다.
				- 리포지터리 패턴으로 IO작업을 캡슐화하는 방법도 있음.

- Part 5: 응집도 : 흩어져 있는 것들
	- 응집도
		- '모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지 나타내는 지표'
		- 모듈은 클래스, 패키지, 레이어 등 다양하다.
		- 응집도가 높으면 변경하기 쉽고 바람직한 구조다. 낮으면 변경시 문제가 발생함.
	1. static 메서드 오용
		- 인스턴스 데이터를 조작할 때 static 메서드를 활용하지 말 것.
			- 로직과 데이터는 한 곳에 뭉쳐서 처리되어야 한다.
		- factory method pattern은 static을 사용하는 것이 좋다.
			- Money 클래스에서 createWon(), createDollar() 이런식으로 생성하기 등
	- 초기화 로직 분산
		- 생성자를 public으로 만들 경우 아무렇게나 초기화될 가능성이 있다.
		- 초기화 로직의 분산을 막으려면 private 생성자를 만들고 factory method를 제공하자
		- 생성 로직이 너무 많을 수도 있다.
			- new A(new B(), new C(), ...) 이런식으로 복잡한 생성자가 존재할 수 있음.
			- factory class를 만들어서 따로 생성해주는 클래스를 만든다.
				- Persistence.createEntityManager() 이런식
	- common/util 범용 클래스 
	- 범용이라고 해서 너무 많은 기능을 담당해서는 안 된다.
		- common의 적절한 예시들
			- 로그 출력
			- 오류 확인
			- 디버깅
			- 예외 처리 
			- 캐시
			- 동기화
			- 분산처리
		- 횡단 관심사에 해당하는 기능은 common이 적절하다.
	- 결과를 리턴하는 데 매개변수 사용하지 않기
		- 매개변수를 전달할 때, 매개변수의 내부 데이터를 조작하지 말 것.
		```
		void shift(Location location, int x, int y) {
			location.x += x;
			location.y += y;
		}	
		```
		- 위와 같은 코드는 로직과 데이터가 흩어져 있는 상태이다. -> 부적절함
		- 데이터는 데이터를 가진 쪽에서 수정하도록 만들 것.
		```
		Location shift(int x, int y) {
			final int nextX = currentX + x;
			final int nextY = currentY + y;
			return new Location(nextX, nextY);
		}	
		```
	- 매개변수가 너무 많은 경우
		- 코드를 보는 사람 입장에서는 바로 이해하기 힘들다.
		- 가능하다면 3개까지 허용하기
		- 기본 자료형으로 전달하지 말고 값만 가지고 있는 객체를 만들어서 유효성 검증을 해당 객체에게 맡기기
	- 메서드 체인
		- get().set().calc().... 이렇게 메서드가 연결되면 안 된다.
		- 해당 클래스 내부를 알고 있는 상태로 코드를 작성해야 함.
		- '문지 말고 명령하기'
		- 메서드로 명령해서 클래스가 알아서 처리하도록 한다.

- Part 6: 조건 분기 : 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법
	- 조건 분기가 중첩되어 낮아지는 가독성
		1. 조기 리턴으로 중첩 제거 (early return)
		2. else 구문 사용하지 말기
			- else if .. return 구조라면 early return으로 해결해보기
	- switch 조건문 중복
		- 요구사항이 추가되면 계속 case가 추가된다. -> 가독성 저하, 실수로 누락할 경우 존재
		1. switch 문을 한 곳에 모아서 분기 처리하기
		2. interface를 사용해서 조건문 중복 해소하기 (상속을 사용해서 분기문 제거)
		3. 전략 패턴 사용하기
			- 2번을 응용한 디자인 패턴
		4. 메서드를 구현하지 않으면 오류로 인식하게 만들기 == 상속을 사용하기
			- switch는 런타임에 문제를 인지할 수 있음.
			- 컴파일 타임에 오류를 인지하는 것이 best
	- 조건 분기 중복과 중첩
		- 가정) 온라인 쇼핑몰 우수 고객 판정 로직
			- 골드
				- 금액 100만원 이상, 한 달에 구매하는 횟수 10회 이상, 반품률 0.1% 이하
			- 실버
				- bla, bla ...
		- policy pattern으로 조건 집약하기
			1. policy interface 만들기
			2. policy 조건을 만족하는 메서드 구현
			3. 정책을 복합적으로 사용할 경우 set에 넣어서 iteration을 돌아 조건 여부 확인
			- rule 클래스, rule을 사용하는 클래스(정책), 정책을 사용하는 클래스 이렇게 나뉜다.
	- 자료형 확인에 조건 분기 사용하지 않기
		- instanceof를 사용하지 말 것. -> 리스코프 치환 원칙을 위반한다.
		- instaceof를 사용하면 분기 코드가 많아진다.
	- 인터페이스 사용 능력이 중급으로 올라가는 첫걸음
		- if, switch -> interface로 바꿔서 사용한다.
		- 분기처리 로직 -> 클래스를 만들어서 로직을 담아둔다.
	- 플래그 매개변수
		- 사용하지 말 것. 가독성이 저하됨.
		1. flag 별 로직은 메서드로 따로 분리한다.
		2. flag 별 로직은 전략 패턴을 사용한다.

- Part 7: 컬렉션 : 중첩을 제거하는 구조화 테크닉
	- 이미 존재하는 기능을 다시 구현하지 말기
	- 반복 처리 내부의 조건 분기 중첩
		- early continue, break : 넘어갈 조건을 가장 위에다 두기
	- 응집도가 낮은 컬렉션 처리
		- 컬렉션을 처리하는 로직이 여기저기 흩어지는 경우
		- 일급 컬렉션을 사용해서 해결
			- List< Memeber > partry -> class party 생성
			- party 처리 로직은 class party가 담당한다.
		- get()과 같이 클래스 내부 정보를 전달할 때는 불변으로 전달하자. (unmodified)

- Part 8: 강한 결합 : 복잡하게 얽혀서 풀 수 없는 구조
	- 결합도와 책무
		- 로직과 데이터가 적절한 클래스에게 배분되어야 한다.
		- 단일 책임 원칙
		- DRY
			- 무조건 중복을 피하라는 뜻은 아니다.
			- 같은 로직, 비슷한 로직이라도 개념이 다르다면 중복을 허용할 수 있다.
	- 다양한 강한 결합 사례와 대처 방법
		1. 상속과 관련된 강한 결합
			- 상속을 사용하면 슈퍼 클래스의 구조를 알고 사용해야 한다. -> 강한 결합
			- 상속은 슈퍼 클래스의 로직과 서브 클래스의 로직이 함께 쓰일 수 있다. -> 로직이 분산됨.
			- 상속보단 조합을 사용할 것.
			- 상속이 나쁜 것은 아니다.
				- 템플릿 메서드, 전략 패턴처럼 활용 가능
				- 상속을 사용하되, 단일 책임 원칙을 염두하여 설계할 경우 상관 없음.
		2. 인스턴스 변수별로 클래스 분할이 가능한 로직
			- 인스턴스 변수 : 메서드 = 1 : 1 인 관계일 경우
				- 클래스로 따로 분리할 수 있다.
			- 즉, 관련 있는 데이터와 로직끼리 따로 묶어서 클래스로 만들어라
		3. 특별한 이유 없이 public 사용하지 말기
			- package private 을 적절히 활용해서 밀접한 클래스끼리 응집력 있게 설계할 수 있다.
			- 정말 외부에 공개할 클래스만 public을 설정하자.
				- test 클래스는 public일 필요가 없다.
		4. private 메서드가 너무 많다는 것은 책임이 너무 많다는 뜻.
			- public도 동일하다.
		5. 높은 응집도를 오해해서 생기는 강한 결합
			- SellingPrice 클래스
				- sellingCommission, deliveryCharge, shoppingPoint
				- 위 개념 모두 SellingPrice를 기반으로 계산이 됨.
				- 하지만 '동일한 개념'이 아니다. -> 로직이 한 곳에 몰려 있음. -> 강한 결합 -> 단일 책임 위반
				- 관련 깊은 로직이라고 생각했지만 결과적으로 강한 결합이 됨.
		6. 거대 데이터 클래스
			- 하나의 클래스에 모든 것을 넣지 말고 유스 케이스마다 필요한 데이터를 가지는 클래스로 쪼갤 것.
				- Order 안에 모든 걸 넣지 말고 Order, Reservation, Delivery 등 여러 클래스로 쪼개서 서로 협력하도록 설계
		7. 트랜잭션 스크립트 패턴
			- 메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조
			- 데이터를 보유하고 있는 클래스와 데이터를 처리하는 클래스가 나누어 구현되었을 때 발생하는 형태
				- orderservice가 get하고 set하고 save하고 등 이런 로직이 트랜잭션 스크립트 패턴
				- 도메인이 얇을 경우 이러한 문제가 발생한다.
			- 하나의 클래스가 수많은 책임을 담당할 경우도 발생한다.
				- RegisterService에서 register, delete, find 등 여러 기능이 다 여기에 있을 수 있음.
			- 수정이 어렵고 읽기 힘들다. 누락할 경우도 생긴다.
		8. 트랜잭션 스크립트 패턴은 결국 god class를 만든다.

- Part 9: 설계의 건전성을 해치는 여러 악마
	1. 데드 코드
		- 가독성을 떨어뜨린다.
		- 버그가 될 가능성이 있다.
		- 발견하면 즉시 제거하는 것이 좋다.
	2. YAGNI 원칙
		- you aren't gonna need it
		- 당장 필요하지 않는 기능을 미리 만들지 마라
		- 결국 데드 코드가 된다.
	3. 매직넘버
		- 숫자는 개발자를 혼란스럽게 만든다.
		- 가능한 숫자는 상수로 바꿔서 사용할 것.
		- 상수의 이름은 의도가 명확해야 한다.
	4. 문자열 자료형에 대한 집착
		- csv처럼 ,으로만 구별된 데이터로 전달되는 경우, 받는 입장에서는 추가적인 작업과 의미를 파악하기 어렵다.
		- 각 변수에 의미에 맞게 담아서 전달하는 것이 좋다.
	5. 전역변수
		- 여러 로직에서 참고하고 값을 변경하면 언제 어떻게 변경되었는지 파악하기 힘들다.
		- 동기화 이슈도 존재
		- 전역변수가 아니라도 '전역변수의 성질'을 가질 수 있다.
			- 책임이 너무 많은 큰 클래스에서 데이터가 여기저기에서 쓰이는 경우
		1. 전역 변수는 영향범위가 최소화되도록 설계하기
	6. null 문제
		- 항상 모든 곳에서 null 체크를 한다면,
			- 가독성이 떨어짐.
			- null 체크를 놓칠 수가 있음. -> 버그 발생
		1. null을 리턴/전달하지 말기
			- null인 데이터는 EMPTY처럼 비어있는 데이터로 표현할 것.
		2. null safety
			- null 안전 자료형을 사용하기 (언어적 지원, Optional 같은 것들)
	7. 예외를 catch하고 무시하는 코드
		- 원인 분석이 어려워진다.
		1. 문제가 발생했다면 소리치기
			- log를 남기거나,
			- 상위 레이어로 에러를 보내거나
	8. 설계 질서를 파괴하는 메타 프로그래밍
		- Reflection API
			- 단점을 잘 이해하고 꼭 필요한 곳에서만 사용할 것.
	9. 기술 중심 패키징
		- model - view - controller 기술 중심
		- 도메인 중심으로 model - view - controller 묶기
	10. 샘플 코드 복붙
		- 샘플 코드는 참고만 할 것.
	11. 은 탄환
		- 은 탄환은 없다.
		- 새로운 기술이라도 신중하게 검토하고 적용해야 한다.

- Part 10: 이름 설계 : 구조를 파악할 수 있는 이름
	1. 관심사에 따라서 각각 클래스로 분할해야 한다.
		- 예
			- 쇼핑몰에서 상품 클래스
				- 재고 관리에도 필요하다. (상품 품목, 수량 등)
				- 예약 상품에도 쓰일 수 있다. (상품의 이름, 수량 등)
				- 결제에도 쓰일 수 있다. (상품의 가격 등)
				- 배송에도 쓰일 수 있다. (상품의 이름, 주문한 상품 목록 등)
			- 관심사에 맞게 상품 클래스 나누기
				- 재고 상품
				- 예약 상품
				- 주문 상품
				- 발송 상품
			- 만약 '위 상품들이 모두 동일한 상품임을 나타내려면?'
				- UUID를 통해서 동일한 상품임을 나타낸다.
		- 이름은 너무 포괄적이면 불분명해진다.
			- 상품
				- 무엇에 관한 상품인가?
				- 상품이라는 클래스는 무슨 역할을 하는가?
			- 주문 상품
				- 상품인데 주문에 관련된 로직과 데이터를 가지고 있다.
				- 명확함.
	2. 이름 설계 - 목적 중심 이름 설계
		- 관심사 분리를 생각해서 비지니스 목적에 맞게 이름을 붙이기.
		- 설계 포인트
			1. 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기
				- 특화된 이름 -> 소프트웨어가 달성하고 싶은 목적.
				- 이름과 관련없는 로직을 배제하기 쉬워진다.
				- 클래스가 작아진다.
				- 관계된 클래스 개수가 적으므로, 결합도가 낮아짐
				- 관계된 클래스 개수가 적으므로, 사양 변경 시 생각해야 하는 영향 범위가 좁음
				- 목적에 특화된 이름을 갖고 있으므로 어떤 부분을 변경해야 할 때 쉽게 찾을 수 있
			1. 존재가 아니라 목적을 기반으로 하는 이름 생각하기
				- 온라인 쇼핑몰에서 '사용자'는? 
					- 법인과 개인을 구별해야 함.
					- 계정, 개인, 프로필, 직무 등으로 나눌 수 있다.
				- 배송을 위한 '주소'는?
					- 발송지, 배송지처럼 특화된 이름이 적합함.
				- '금액'은?
					- 청구 금액, 소비세액, 연체 보증료, 캠페인 할일 금액 등
				- '사용자 이름은?'
					- 계정 이름, 닉네임, 본명, 법인명
				- '상품'은?
					- 입고 상품, 예약 상품, 주문 상품, 발송 상품
			1. 어떤 관심사(비지니스 목적)가 있는지 분석하기
				- 관심사에 특화된 이름을 만들기 위해서는 해당 소프트웨어가 추구할 목적을 분석해야 한다.
				- 관련 내용을 나열하고 관계를 정리하고 분석하기
			1. 소리 내어 이야기해 보기
				- 목적과 의도의 방향성을 알기 위해서 타인에게 설명해보기
			1. 이용 약관 읽어 보기
				- usecase를 문서화한 것?
			2. 다른 이름으로 대체할 수 없는지 검토하기
				- 꼬리를 물면서 질문하기
			3. 결합이 느슨하고 응집도가 높은 구조인지 검토하기
				- 목적 이외의 로직이 섞인다? -> 이름이 적합한지 검토하기
				- 다른 클래스와 관련된 개수를 확인하기 -> 가능한 적을 수록 좋다.
				- 좁은 의미로 이름을 지으면 현실세계와 정보 시스템의 모델 간 1:n 관계로 대응된다.
					- 상품 <-> 주문상품, 예약상품, 재고상품...
					- 사용자 <-> 법인, 개인, 계정, 프로필 ...
	3. 이름 설계 시 주의 사항
		1. 이름에 관심 갖기
			- 이름과 로직이 대응된다.
			- 이름이 프로그램 구조를 크게 좌우한다.
			- 팀원들끼리 이름이 중요하다는 것을 공유해야 한다
		2. 사양 변경 시 '의미 범위 변경' 경계하기
			- 여러 의미가 섞이면 이름이 의미하는 것을 검토해봐야 함.
			- 이름을 변경하거나, 클래스를 나눠야 함.
		3. 대화에는 등장하지만 코드에 등장하지 않는 이름 주의
			- 묻지 않으면 알 수 없고 존재를 확인해도 로직을 이해하기 힘들다.
			- 대화에 등장하는 이름을 신경쓸 것. 그것을 기반으로 클래스, 메서드를 설계할 것.
		4. 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기
			- 최대 히트포인트 계산 로직
				- 어떤 경우에 최대 히트포인트가 적용되는가?
				- '장비와 버프가 없는 상태의 최대 히트포인트'
				- 이러한 수식어가 있어야 구별할 수 있다면, 로직과 클래스에 정확히 반영하기.
				- currentMaxHitPoint(), originalMaxHitPoint() 등
			- 이렇게 구구절절 수식어가 붙는 로직이 여기저기서 퍼져 있다면 클래스로 만들어 보기.
				- class CurrentMaxHitPont 
				- 계산 로직, 허용 범위, 기본 초기화 등 응집력 향상 가능
			- 또 다른 예
				- flag가 true인 User는 휴먼 계정이다.
					- ActiveUser, NonActiveUser로 구별
				- 여기에서 Price는 신품의 가격이고 여기에서는 중고 가격이다.
					- OriginalPrice, UsedPrice 구별
				- Ticket 클래스에서 60살 이상 노인에게는 할인이 부가된다. 하지만 평일에만 적용된다.
					- WeekendOldManTicket, WeekendOldManTicket 구별
			- 과연 어디서 부터 나눠야 하는가?
				- 정확히 여기서부터 클래스로 분리라는 개념은 없는듯.
				- 처음부터 모든걸 클래스로 나눠서 생각하면 구조가 너무 복잡하고 클래스에 계속 기능을 추가하면 유지보수가 어렵다.
				- 적절한 중간 지점은 경험으로 채워야 정답일 듯.
				- 일단 척도 1
					- 단일 책임 원칙을 잘 지키면 단위 테스트를 작성하기 쉽다.
	4. 의미를 알 수 없는 이름
		- temp, i, j, k
		- memory, cache, thread, register, integer, module 기술적인 이름들
			- 하드웨어에 가까운 쪽이라면 어쩔 수 없다.
		- isMembeHpMoreThanZeroAndIsMemberCanActAndIsMemberMpMoreThanSpell()
			- 메서드로 줄줄줄 로직을 설명하지 말기
			- 가능한 간단하고 의도를 파악하기 쉬운 이름으로
		- 놀람 최소화 원칙
			- rule of least surprise
			- 엉뚱한 이름에 값을 넣거나 계산하지 말 것
			- 로직과 이름을 잘 대응시키기
	5. 구조에 악영향을 미치는 이름
		1. 데이터 클래스처럼 보이는 이름
			- ~Info, ~Data 등 -> 피할 것.
			- '데이터만 가지고 있으니 로직을 구현하면 안 되는구나'라는 이미지를 심어 줄 수 있다.
				- ProductInfo(id, name, price ...) -> Product(...)
			- 단, DTO는 예외
				- 단순 참조용도로 사용할 것. 내부에서 값을 변경하지 말 것.
			- 데이터 클래스를 절대 사용하지 말 것. (x) -> 의도와 상황에 맞게 사용할 것.
				- VO는 데이터 클래스로 표현해도 괜찮은데, entity는 데이터 클래스처럼 보이게 만들지 말라는 뜻인가?
		2. 클래스를 거대하게 만드는 이름
			- Price, Manager, Item, Product ...
			- 이름으로 정확하게 어떤 기능을 담고 있는 객체인지 알 수 없다.
				- 가격은 할인? 정가?, 관리자는 어디 관리자?
			- 요구사항이 추가되면서 해당 클래스만 계속 기능이 추가된다. (변경이 됨)
				- 결국 거대한 클래스가 됨 -> 단일 책임 원칙이 무너짐
				- 마찬가지로 MVC에서 Controller라는 이름도 주의할 것.
					- get, put, delete 등 다양한 작업이 있는데 하나의 컨트롤러에서 담당하면 안 됨.
					- controller는 매개변수를 전달하는 역할만 수행한다.
		3. 상황에 따라 의미가 달라질 수 있는 이름
			- Account
				- 금융에서는 계좌, 보안에서는 로그인 권한
			- 컨텍스트가 다르다면 다른 클래스로 분리한다.
			- 각 컨텍스트는 서로 다른 패키지로 선언한다.
				- 여러 컨텍스트에서 동일한 객체임을 나타내고 싶다면 UUID를 할당할 것.
					- 예) 상품이 재고 관리, 배송, 상품 조회 등에서 동일한 의미를 나타낼 때
		4. 일렬번호 명명
			- method1, method2 ... -> 하지마셈
	6. 이름을 봤을 때, 위치가 부자연스러운 클래스
		1. 동사 + 목적어 메서드 이름 주의하기
			- consumeMagincPoint(), addItemToParty() ...
			- 클래스가 다루는 관심사와 멀어지면 위와 같은 형태가 나올 수 있다.
			- 해당 클래스의 관심사와 같다면 상관이 없을까?
		2. 가능하다면 메서드의 이름은 동사 하나로 구성되게 하기
		3. 부적절한 위치에 있는 boolean 메서드
			- ' 클래스 is, can, has 상태 '
			- 위처럼 번역했을 때 자연스러우면 해당 클래스가 가질 boolean 메서드
	7. 이름 축약
		- 가능한 축약하지 말 것.
		- 일부 언어에서는 짧은 표현을 선호하기도 한다.
		- 팀 규칙에 따라 축약 범위를 정할 것.

- Part 11: 유지 보수와 변경의 정확성을 높이는 주석 작성 방법
	- 주석을 유지보수하는 것은 어렵다.
	- 주석이 실제 코드가 아님을 인지할 것.
	- 주석도 규칙이 있어야 함.

- Part 12: 메서드(함수) - 좋은 클래스에는 좋은 메서드가 있다.
	1. 반드시 현재 클래스의 인스턴스 변수 사용하기
		- 메서드는 현재 클래스의 인스턴스 변수를 사용해야 한다.
		- 다른 클래스가 인스턴스 변수를 변경하도록 하지 말 것.
		- 다른 클래스의 인스턴스 변수를 변경하고 싶다면, 변경된 내용을 다루는 새로운 인스턴스 변수를 생성하고 이것을 리턴할 것. (복사본을 만들어서 준다. 단, 얕은 복사본은 안 됨)
	2. 불변을 이용해서 예상할 수 있는 메서드 만들기.
		- 변경할 일이 없다면 처음부터 불변으로 만들어라
	3. 묻지 말고 명령하기
		- getter/setter는 조작할 수 있는 메서드 구조. 그리 권장하는 네이밍이 아님.
		- 메서드를 호출하면 알아서 해당 작업을 진행하고 결과만 돌려주는 형태로 만들어라
	4. command / query 분리
		- 커맨드 : 상태를 변경하는 것
		- 쿼리 : 상태를 리턴하는 것
		- 모디파이어 : 커맨드와 쿼리를 동시에 하는 것.
		- 모디파이어는 최대한 피할 것.
	5. 매개변수
		- 불변으로 만들 것.
		- 플래그 매개변수는 사용하지 말 것. 플래그가 있으면 메서드 시그니처로만 코드를 파악하기 어렵다. 내부를 까봐야 함.
		- null 전달하지 말 것. 차리리 빈 값을 나타내거나 Optional 사용
		- 출력 매개변수를 사용하지 말 것.
		- 매개변수의 수는 최대한 적게 사용하기. 길면 시그니처로 유추하기 어렵다.
	6. 리턴값
		1. 리턴값으로 의도를 명확하게 하기.
			- 기본 자료형은 의미가 모호하다.
			- 독자적인 자료형을 만들어서 전달해 의미를 명확하게 하기
		2. 오류는 리턴 값으로 리턴하지말고 예외 발생시키기

- Part 13: 모델링 - 클래스 설계의 토대
	- 모델 : 특정 목적을 달성하기 위해 최소한으로 필요한 요소를 갖춘 것.
		- 목적을 달성하기 위한 최소한의 구성 요소가 무엇일지 파악한다.
		- 예) 상품이라고 해서 '배송'과 '재고관리'에서 '상품'의 구성요소가 달라질 수 있다.
	- 안 좋은 모델의 문제점과 해결방법
		- 여러 목적에 무리하게 사용되고 있으면 제대로된 모델링이 아니다.
		- 예) User 클래스가 법인, 개인, 사용자 프로필 등 계속해서 여러 개념들이 추가되거나 포함하고 있는 경우.
		- 목적별로 모델링하기
			- 특정 목적을 달성할 최소한의 구성요소로 모델 만들기
			- 개인계정, 법인계정, 프로필 등
		- 모델은 대상이 아니라 목적 달성의 수단
			- '대상'으로 바라볼 경우 '모든 목적이 담길 수 있다.'
				- 예) User, Product, Item...
			- 목적으로 바라볼 것.
				- 개인으로 로그인을 위한 PersonalAccount
				- 사용자 정보 표현을 위한 Profile
		- 단일 책임 == 단일 목적
		- 모델을 다시 확인하는 방법
			1. 해당 모델이 달성하려는 목적을 모두 찾아낸다 == usecase 찾아내기
			2. 목적별로 모델링을 다시 수정
			3. 목적 중심 이름 설계를 기반으로 모델에 이름 붙이기
			4. 모델에 목적 이외의 요소가 들어가 있다면 다시 수정
		- 모델과 구현은 반드시 서로 피드백하기
			- 모델 != 클래스
			- 클래스 설계와 구현에서 무언가 깨닫는다면, 모델에 피드백할 것.
			- 1개의 모델 != 1개의 클래스
			- 1개의 모델은 여러 클래스로 구현될 수도 있다.
	- 기능성을 좌우하는 모델링
		1. 숨어 있는 목적 파악하기
			- 상품을 구입한다면?
				- 그냥 상품을 구입하는 것이 아니다.
				- 온라인 쇼핑몰의 경우 '상품 등의 매매 계약'이 체결되는 것.
				- 매매 계약에 필요한 것이 무엇인가, 법적 문제는 없는가 등 고려할 것이 많다.
		2. 기능성을 혁신하는 '깊은 모델'
			- 동물 - 포유류 - 고양이 상속 구조
				- 너무 범위가 한정된다.
			- 영양 섭취 수단
				- 고등어, 돼지, 가공식품, 수액 등 범위가 굉장히 넓다.
			- 좋은 모델은 넓은 범위를 가지고 다양하게 확장할 수 있다.

- Part 14: 리팩터링 - 기존의 코드를 성장시키는 기술
	- 리팩터링 : 현재 동작을 유지시키면서, 구조만 정리하는 작업
	- 리팩터링을 하다보면 버그가 발생할 수 있다. -> 단위 테스트로 실수를 방지
	- 주의사항
		- 기능 추가와 리팩터링은 동시에 하지 않는다.
		- 작은 단계로 실시한다.
		- 불필요한 사양은 제거

- Part 15: 설계의 의의와 설계를 대하는 방법
	- 나쁜 설계는 생산성이 낮다.
	- 이러한 레거시는 부채처럼 쌓인다. 미리미리 해결해야 함.
	- 레거시 코드는 엔지니어 성장에 방해가 됨.
	- 코드의 좋고 나쁨을 판단하는 지표
		1. 실행되는 코드의 수
			- 메서드는 10줄 이내
			- 클래스는 100줄 이내
		2. 순환 복잡도
			- 조건분기, 반복문, 중첩은 복잡도를 높인다.
			- 위를 정량적으로 측정한 '순환 복잡도'는 낮을 수록 좋다.
		3. 응집도
			- 응집도가 높을 수록 변경 용이성이 좋다
		4. 결합도
			- 도구를 통해 분석 가능하다.
		5. 청크
			- 인간의 단기 기억 단위는 3~5개 정도
			- 이러한 인지능력의 한계를 고려해서 코드를 작성해야 한다.

- Part 16: 설계를 방해하는 개발 프로세스와의 싸움
	1. 커뮤니케이션이 부족하면 설계 품질에 문제가 발생한다.
	2. '빨리 끝내고 싶다'는 심리가 품질 저하의 함정이다.
	3. 나쁜 코드가 결국 시간을 더 많이 잡아먹게 된다.
	4. 클래스 설계와 구현 피드백 사이클을 돌려야 한다.
	5. 한번에 완벽하게 설계하려고 들지 말고, 사이클을 돌리며 완성하기.
	6. 성능 때문에 클래스를 작게 나누지 말자? -> 실제로 측정해보고 결정하기. (이른 최적화)
	7. 설계 규칙은 다수결보다 역량이 뛰어난 사람을 중심으로 결정하기
	8. 기존 코드를 믿지말고 냉정하게 분석해서 동작을 파악하기
	9. 코딩 규칙 사용하기
	10. 명명 규칙 사용하기
	11. 코드 리뷰를 구조화하기
	12. 코드를 설계 시점에 리뷰하기
	13. 존중과 예의를 지켜라.
	14. 정기적으로 개선 작업을 진행할 것.
	15. 
### References
---
[]()
