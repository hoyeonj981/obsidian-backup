created at : 2024-09-17 15:48

#### tags

#

--- 
- 다양한 마이크로 최적화가 적용되었다.
	- 불필요한 메서드 호출을 안 하기
	- lock-free 알고리즘, 캐싱, queue-stealing ...
	- 바이트코드 호출 최적화
	- false-sharing 줄이기
### 1. **정적 디스패치 vs 동적 디스패치**

- **`invokestatic` (정적 메서드 호출)**:
    
    - 정적 메서드는 **컴파일 시점**에 호출할 메서드가 확정되며, **정적 디스패치** 방식으로 호출됩니다.
    - 즉, **클래스**에 속한 메서드이기 때문에 메서드 호출이 고정되고, 다형성(polymorphism)에 의해 변경되지 않습니다.
    - 이로 인해 JVM은 호출하는 메서드가 런타임에 변경되지 않음을 보장할 수 있으며, **인라이닝(inlining)**, **메서드 캐싱**과 같은 최적화를 쉽게 수행할 수 있습니다.
- **`invokevirtual` (인스턴스 메서드 호출)**:
    
    - 반면, `invokevirtual`은 **동적 디스패치** 방식으로 메서드를 호출합니다. 이는 호출할 메서드가 **런타임**에 객체의 실제 타입에 따라 결정되며, 다형성이 작동하는 경우가 많습니다.
    - JVM은 이 메서드 호출이 어느 객체의 어떤 메서드인지 미리 알 수 없으므로, 런타임에 **vtable**(virtual method table)을 통해 메서드를 탐색해야 합니다. 이 탐색 과정이 추가 비용을 발생시키며, 최적화에 제약이 생깁니다.

### 2. **최적화의 용이성**

- **`invokestatic` 최적화**:
    
    - `invokestatic` 호출은 **정적 메서드**로, JVM은 해당 메서드가 어떤 클래스에 속해 있는지 미리 알고 있습니다. 따라서 호출할 메서드를 미리 결정할 수 있으며, 추가적인 런타임 검사나 탐색 없이 바로 메서드를 호출할 수 있습니다.
    - JVM은 이러한 호출을 **인라인**(메서드 호출 코드를 해당 호출 지점에 직접 삽입)하거나 **JIT(Just-In-Time) 컴파일러**가 성능 최적화를 할 수 있습니다.
- **`invokevirtual` 최적화**:
    
    - `invokevirtual`은 **동적 디스패치**가 필요하므로, JVM은 런타임에 객체의 실제 타입을 확인하고, 적절한 메서드를 탐색해야 합니다. 이를 위해 **vtable**을 사용하여 메서드를 찾아야 하며, 이는 추가적인 성능 오버헤드를 초래할 수 있습니다.
    - 다만, JVM은 **HotSpot** JIT 컴파일러를 통해 **call-site 캐싱**(동적 메서드 호출에 대한 캐시)이나 **가상 메서드 테이블 최적화**와 같은 기법을 사용하여 `invokevirtual` 호출도 상당히 빠르게 최적화할 수 있습니다. 특히, **메서드 인라이닝**은 런타임에 빈번히 호출되는 메서드에 대해 다형성을 분석하여 최적화할 수 있습니다.
    - 그러나 여전히 `invokestatic`보다 최적화가 복잡하고 덜 효율적일 수 있습니다.

### 3. **다형성의 복잡성**

- 다형성이 많은 상황에서 `invokevirtual`은 런타임에 객체의 타입이 다를 수 있기 때문에 최적화가 제한적입니다. 반면 `invokestatic`은 호출 대상이 고정되어 있으므로 최적화에 유리합니다.

### 결론

- **`invokestatic`**은 JVM에서 더 쉽게 최적화할 수 있습니다. 호출할 메서드가 고정되어 있고, 런타임에 동적 디스패치를 처리할 필요가 없기 때문입니다.
- 반면 **`invokevirtual`**은 다형성과 런타임 메서드 탐색의 복잡성 때문에 최적화가 더 어렵지만, JVM의 JIT 컴파일러와 메서드 캐싱 최적화를 통해 성능 저하를 최소화할 수 있습니다.

### References
---
[]()
https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole